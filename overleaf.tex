\documentclass[12pt,oneside]{book}

% =======================
% Pacotes essenciais
% =======================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{textcomp}              % símbolos extras com pdfLaTeX
\usepackage{lmodern}               % família Latin Modern (T1)
\usepackage{graphicx}
\usepackage{amsmath, amssymb}
\usepackage{lipsum}
\usepackage{setspace}
\usepackage[dvipsnames]{xcolor}
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{parskip}
\usepackage{tcolorbox}
\usepackage{makeidx}
\makeindex

% Fontes profissionais
\usepackage[sfdefault]{sourcesanspro} % Texto (sans como padrão)
\usepackage{FiraMono}                  % Código (monoespaçada)

% =======================
% Estilo dos códigos (Importação externa)
% =======================
\input{code-style.tex}

% Espaçamento confortável
\setstretch{1.2}

% =======================
% Aparência dos títulos
% =======================
\titleformat{\chapter}[block]
  {\normalfont\huge\bfseries\color{RoyalBlue}}
  {\thechapter\hspace{0.5em}}{0pt}{}

\titleformat{\section}[block]
  {\normalfont\Large\bfseries\color{MidnightBlue}}
  {\thesection\hspace{0.5em}}{0pt}{}

\titleformat{\subsection}[block]
  {\normalfont\large\bfseries\color{black}}
  {\thesubsection\hspace{0.5em}}{0pt}{}

% =======================
% Aparência do sumário
% =======================
\renewcommand{\contentsname}{Sumário}

\titlecontents{chapter}
  [1em]{\addvspace{0.5em}\bfseries\color{RoyalBlue}}
  {\thecontentslabel\hspace{0.5em}}{}{\hfill\contentspage}

\titlecontents{section}
  [2.5em]{\small\color{MidnightBlue}}
  {\thecontentslabel\hspace{0.5em}}{}{\hfill\contentspage}

\titlecontents{subsection}
  [4.5em]{\footnotesize\color{black}}
  {\thecontentslabel\hspace{0.5em}}{}{\hfill\contentspage}

% =======================
% Caixas Profissionais
% =======================
\tcbset{
  boxsep=5pt, left=5pt, right=5pt, top=5pt, bottom=5pt,
  colframe=RoyalBlue, colback=gray!5,
  arc=4pt, boxrule=0.7pt
}

\newtcolorbox{infobox}[1][]{
  colback=blue!5!white, colframe=RoyalBlue, title={Informação}, #1
}
\newtcolorbox{warningbox}[1][]{
  colback=red!5!white, colframe=red!60, title={Atenção}, #1
}
\newtcolorbox{tipbox}[1][]{
  colback=green!5!white, colframe=ForestGreen, title={Dica}, #1
}
\newtcolorbox{examplebox}[1][]{
  colback=yellow!10!white, colframe=Goldenrod, title={Exemplo}, #1
}

% =======================
% Metadados
% =======================
\title{Título do Ebook}
\author{Felipe Jovino dos Santos}
\date{\today}

% =======================
% Hyperlinks (carregar quase por último no PREÂMBULO)
% =======================
\usepackage[hidelinks]{hyperref}
\urlstyle{same} % manter estilo de URL igual ao texto
\hypersetup{
  unicode=true,
  pdftitle={Título do Ebook},
  pdfauthor={Felipe Jovino dos Santos}
}


% =======================
% Documento
% =======================
\begin{document}

% Capa
\begin{titlepage}
  \centering
  \vspace*{5cm}
  {\Huge\bfseries Ecossistema AdonisJS: Guia Completo para Desenvolvedores\par}
  \vspace{2cm}
  {\Large\itshape Felipe Jovino dos Santos\par}
  \vfill
  {\large \today\par}
\end{titlepage}

\clearpage

% Ficha Catalográfica
\thispagestyle{empty}
\begin{center}
  \textbf{Ficha Catalográfica}\\
  \rule{0.8\textwidth}{0.5pt}\\[1em]
  \begin{minipage}{0.8\textwidth}\small
    SANTOS, Felipe Jovino dos Santos.\\
    \textbf{Título do Ebook}: Ecossistema AdonisJS: Guia Completo para Desenvolvedores / Felipe Jovino dos Santos. -- 1. ed. -- [Local], \the\year.\\
    \vspace{0.5em}
    \textbf{1.} Programação. \textbf{2.} Desenvolvimento de Software. \textbf{3.} Tecnologias.\\
    \textit{CDD 005.1}
  \end{minipage}
\end{center}

\clearpage

% Direitos Autorais
\thispagestyle{empty}
\begin{center}
  \vspace*{\fill}
  \begin{minipage}{0.8\textwidth}
    \centering

    \textbf{Copyright © \the\year\ Felipe Jovino dos Santos} \\[0.5cm]
    Este livro está licenciado sob \textbf{Creative Commons Atribuição-NãoComercial 4.0 Internacional}.\\
    Permite-se compartilhar, copiar, distribuir e adaptar, com crédito ao autor e sem fins comerciais.\\[0.3cm]

    Termos completos: \url{https://creativecommons.org/licenses/by-nc/4.0/deed.pt}

    \textit{Primeira edição – \the\year}
  \end{minipage}
  \vspace*{\fill}
\end{center}

\clearpage

% Sumário
\tableofcontents
\clearpage

% =======================
% Prefácio
% =======================
\chapter*{Prefácio}
\addcontentsline{toc}{chapter}{Prefácio}

O desenvolvimento web moderno exige muito mais do que apenas saber programar. Ele demanda compreender ecossistemas, ferramentas e boas práticas que, quando bem aplicadas, não só aceleram o desenvolvimento, mas também garantem a escalabilidade, segurança e manutenibilidade de projetos.

O \textbf{AdonisJS} é mais do que um framework. Ele representa uma proposta robusta, opinativa e elegante para o desenvolvimento backend em Node.js, oferecendo uma experiência de desenvolvimento fortemente inspirada nos frameworks maduros do ecossistema PHP e Ruby. Mais do que isso, ele é sustentado por um ecossistema completo: \textbf{Lucid ORM}, \textbf{EdgeJS}, \textbf{VineJS} e \textbf{Japa}, que juntos oferecem soluções integradas para banco de dados, templates, validação e testes.

Este livro surge da necessidade — que também é minha, enquanto desenvolvedor backend que utiliza o AdonisJS profissionalmente — de termos uma fonte única, organizada, objetiva e prática. Um material que sirva tanto como guia de aprendizagem quanto como referência técnica para o dia a dia de quem trabalha com este framework.

Embora a documentação oficial do AdonisJS seja extremamente bem estruturada, a proposta aqui é apresentar o conteúdo de forma sequencial, didática e aprofundada, consolidando os principais conceitos, práticas, padrões de desenvolvimento e, principalmente, trazendo reflexões baseadas na minha experiência real utilizando o AdonisJS em projetos profissionais.

Ao longo destas páginas, você encontrará não apenas comandos, códigos e conceitos, mas também boas práticas, sugestões arquiteturais, alertas sobre armadilhas comuns e dicas valiosas que dificilmente são percebidas na primeira leitura da documentação — e que muitas vezes só são compreendidas no uso prático e na solução de problemas reais.

Este livro foi pensado para quem deseja dominar o \textbf{ecossistema completo do AdonisJS} — desde a criação de APIs robustas, gestão de dados com o \textbf{Lucid ORM}, desenvolvimento de templates dinâmicos com o \textbf{EdgeJS}, até a construção de testes eficientes com o \textbf{Japa} e validações poderosas com o \textbf{VineJS}.

\medskip

\noindent Este material reflete não apenas minha jornada com o AdonisJS, mas também minha trajetória profissional. Atualmente, sou bacharelando em Sistemas de Informação pelo Instituto Federal de Sergipe (IFS), com sólida atuação em desenvolvimento Full Stack utilizando tecnologias como \textbf{AdonisJS}, \textbf{Next.js}, \textbf{TypeScript} e \textbf{PostgreSQL}, além de uma ampla vivência em \textbf{microeletrônica} e \textbf{sistemas embarcados} com \textbf{ESP32}.

Atuei como pesquisador no \textbf{Laboratório de Inovação e Criatividade (LABIC)}, desenvolvendo projetos que unem \textbf{Inteligência Artificial}, eletrônica e sistemas embarcados. Fui participante da \textbf{Mostra Nacional de Robótica 2023}, além de autor de publicações acadêmicas sobre acesso à formação em IA para pessoas de baixa renda. Minha atuação também incluiu papel como \textbf{instrutor} e \textbf{mentor} em diversos projetos de capacitação tecnológica, como o \textbf{Projeto Aprendiz 4.0} e a \textbf{Residência em TIC}.

Hoje também compartilho conhecimento como \textbf{criador de conteúdo educacional} no YouTube, buscando democratizar o acesso à tecnologia e capacitar profissionais da área de desenvolvimento de software.

Minha missão com este livro é a mesma que carrego em toda minha trajetória: \textbf{tornar o conhecimento acessível}, descomplicado e aplicável. Que esta obra te ajude não só a dominar o AdonisJS, mas também a construir projetos mais profissionais, escaláveis e de alta qualidade.

\medskip

\noindent Boa leitura e bons códigos!

\bigskip

\noindent \textbf{Felipe Jovino dos Santos} \\
\textit{Desenvolvedor Full Stack | Especialista em AdonisJS | Criador de Conteúdo | Pesquisador em IA e Sistemas Embarcados}

% =======================
% Objetivos
% =======================
\chapter*{Objetivos do Livro}
\addcontentsline{toc}{chapter}{Objetivos do Livro}

Este livro tem como principal objetivo ser uma fonte de referência completa e prática sobre o \textbf{ecossistema AdonisJS}, reunindo conhecimentos teóricos, técnicos e aplicáveis em um único material.

Os objetivos específicos são:

\begin{itemize}
  \item \textbf{Apresentar de forma estruturada e sequencial todos os componentes do ecossistema AdonisJS}, incluindo Lucid ORM, EdgeJS, VineJS e Japa.
  \item \textbf{Fornecer uma visão abrangente, prática e profissional} sobre o desenvolvimento backend com Node.js utilizando AdonisJS.
  \item \textbf{Ensinar boas práticas, padrões arquiteturais e organização de projetos}, contribuindo para o desenvolvimento de aplicações robustas, escaláveis e seguras.
  \item \textbf{Capacitar o leitor a compreender profundamente cada ferramenta}, desde conceitos básicos até tópicos avançados como autenticação, segurança, testes, deploy e performance.
  \item \textbf{Servir como material de apoio, consulta e aperfeiçoamento contínuo} para desenvolvedores de todos os níveis, desde iniciantes até profissionais experientes.
  \item \textbf{Promover a autonomia do leitor no desenvolvimento de APIs e sistemas completos}, utilizando todo o potencial oferecido pelo ecossistema AdonisJS.
\end{itemize}

% =======================
% Público-Alvo
% =======================
\chapter*{Público-Alvo}
\addcontentsline{toc}{chapter}{Público-Alvo}

Este livro foi desenvolvido para atender diferentes perfis de profissionais e entusiastas da tecnologia que desejam dominar o ecossistema AdonisJS e suas ferramentas complementares. O conteúdo foi cuidadosamente estruturado para ser acessível, progressivo e ao mesmo tempo aprofundado.

\begin{itemize}
  \item \textbf{Iniciantes em desenvolvimento backend}, que buscam um guia didático e bem estruturado para dar os primeiros passos no desenvolvimento de APIs, sistemas e aplicações com Node.js.
  \item \textbf{Estudantes de cursos técnicos, de graduação e de pós-graduação em áreas de tecnologia}, que desejam complementar sua formação com práticas modernas e alinhadas ao mercado.
  \item \textbf{Desenvolvedores frontend que desejam migrar ou expandir suas competências para o backend}, encontrando no AdonisJS uma abordagem familiar, estruturada e produtiva.
  \item \textbf{Desenvolvedores backend de outras linguagens (como PHP, Python, Java ou C\#)}, que desejam adotar o ecossistema Node.js com uma curva de aprendizado mais suave, através de um framework inspirado nos padrões de frameworks maduros.
  \item \textbf{Profissionais experientes que desejam aprimorar seus conhecimentos em arquitetura de software, boas práticas, testes, segurança, deploy e desenvolvimento backend moderno} com foco em produtividade e escalabilidade.
  \item \textbf{Empreendedores, freelancers e equipes técnicas} que buscam uma base sólida para desenvolver produtos digitais, APIs robustas e sistemas de alta qualidade utilizando o ecossistema AdonisJS.
\end{itemize}


% =======================
% Como Utilizar o Livro
% =======================
\chapter*{Como Utilizar Este Livro}
\addcontentsline{toc}{chapter}{Como Utilizar Este Livro}

Este livro foi cuidadosamente estruturado para oferecer uma jornada de aprendizado progressiva e prática. Cada parte e capítulo segue uma ordem lógica, começando pelos fundamentos e avançando até tópicos mais complexos, sempre mantendo uma abordagem didática, orientada a exemplos e alinhada às boas práticas do desenvolvimento backend moderno.

Embora seja altamente recomendado que você leia os capítulos na sequência, principalmente se estiver começando, este material também foi projetado para servir como uma referência prática no seu dia a dia profissional. Sempre que necessário, você pode consultar seções específicas de maneira independente, seja para revisar conceitos, buscar exemplos de implementação, esclarecer dúvidas ou aprofundar seu entendimento sobre algum tema.

Ao longo do livro, você encontrará explicações teóricas, exemplos de código comentados, boxes de dicas, alertas e boas práticas, além de capítulos dedicados à integração entre os principais componentes do ecossistema AdonisJS: Lucid ORM, EdgeJS, VineJS e Japa.

Utilize este material tanto como um guia de estudo quanto como um manual de referência no desenvolvimento de aplicações backend profissionais, escaláveis e seguras com Node.js e AdonisJS.

% =======================
%  AdonisJS Framework
% =======================
\part{AdonisJS Framework}

\chapter{Prefácio e Introdução}

\section{Introdução}

AdonisJS é muito mais do que apenas um framework backend para Node.js — ele é uma proposta clara de como construir aplicações robustas, seguras e escaláveis com uma experiência de desenvolvimento impecável. Enquanto outros frameworks se apoiam em uma filosofia minimalista — delegando ao desenvolvedor a escolha de dezenas de pacotes para formar seu stack — AdonisJS oferece uma abordagem opiniosa, porém elegante, fornecendo um ecossistema completo com tudo que você precisa para começar e terminar um projeto profissional.

O que diferencia o AdonisJS não é apenas sua adoção irrestrita do TypeScript desde o núcleo, mas a clareza e organização que ele oferece na construção de aplicações. Aqui, você não perde tempo decidindo sobre estrutura de pastas, gerenciamento de middlewares, autenticação, ou como lidar com tarefas como uploads, envio de emails ou agendamento de jobs. Tudo isso já vem padronizado, seguindo boas práticas e integrado nativamente.

Além disso, o framework é frontend agnostic. Isso significa que você é livre para escolher entre trabalhar com templates server-side utilizando EdgeJS, construir uma API REST ou GraphQL, ou até mesmo utilizar uma abordagem híbrida como Inertia, integrando React, Vue ou qualquer outro frontend moderno com o backend.

A curva de aprendizado é proporcionalmente suave para quem já tem conhecimento prévio de conceitos como MVC, roteamento e bancos de dados relacionais, mas, ao mesmo tempo, profundamente enriquecedora, pois o AdonisJS incentiva o uso de padrões profissionais desde o início.

O ecossistema inclui ferramentas como:

\begin{itemize}
  \item \textbf{EdgeJS}, um dos melhores template engines da atualidade, com sintaxe clara e integração profunda.
  \item \textbf{Lucid ORM}, que proporciona uma experiência de banco de dados robusta, simples, mas poderosa, comparável a ORMs maduros como Eloquent (Laravel) ou Sequelize.
  \item \textbf{VineJS}, um sistema de validação tipado, absurdamente robusto e elegante, que evita dores de cabeça comuns na validação de dados.
  \item \textbf{Japa}, um framework de testes moderno, leve e extremamente eficiente para o desenvolvimento seguro e sustentável de aplicações.
\end{itemize}

A comunidade é ativa, vibrante e extremamente receptiva. Você pode contar com o Discord oficial, discussões no GitHub, redes sociais e contribuições constantes de desenvolvedores apaixonados pelo projeto.

Ao longo deste capítulo e deste livro, você não vai apenas aprender o que está na documentação. Vai entender como o AdonisJS se comporta na prática, quais são os padrões que funcionam melhor, quais armadilhas evitar, além de receber dicas que só quem utiliza AdonisJS em projetos reais — desde APIs simples até sistemas complexos em produção — pode compartilhar.

Seja bem-vindo(a) a um dos melhores frameworks web da atualidade no ecossistema Node.js.

\chapter{Primeiros Passos}
\section{Instalação}

\begin{infobox}
  Antes de começar, é fundamental ter instalado em seu ambiente o \textbf{Node.js} na versão \textbf{20 ou superior}. O AdonisJS depende diretamente dessa versão mínima para funcionar corretamente.
\end{infobox}

\subsection{Verificando o Node.js}

Verifique se possui o Node.js instalado com o seguinte comando no terminal:

\lstinputlisting[
  language=bash,
  caption={Verificando a versão do Node.js},
  label={lst:node_version_check}
]{snippets/primeiros-passos/node_version_check.sh}

Se não tiver, você pode instalar diretamente pelo site oficial \url{https://nodejs.org} ou, preferencialmente, utilizar o \textbf{Volta} (\url{https://volta.sh}) — um gerenciador de versões que permite maior controle e consistência no ambiente de desenvolvimento.

\subsection{Criando um Novo Projeto}

O AdonisJS oferece um comando simples para inicializar um novo projeto utilizando o seguinte comando:

\lstinputlisting[
  language=bash,
  caption={Criando um novo projeto AdonisJS},
  label={lst:adonis_new_project}
]{snippets/primeiros-passos/adonis_new_project.sh}

\begin{warningbox}
  Quando utilizar parâmetros no comando \texttt{npm init}, lembre-se de adicionar \texttt{--} (dois hífens) antes dos parâmetros para garantir que o npm os repasse corretamente.
\end{warningbox}

\subsection{Parâmetros mais comuns}

Você pode personalizar seu projeto logo na criação usando os seguintes parâmetros:

\begin{itemize}
  \item \texttt{--kit}: Define o kit inicial do projeto. Opções: \texttt{web}, \texttt{api}, \texttt{slim}, \texttt{inertia}.
  \item \texttt{--db}: Define o banco de dados. Opções: \texttt{sqlite}, \texttt{postgres}, \texttt{mysql}, \texttt{mssql}.
  \item \texttt{--git-init}: Inicializa um repositório Git (opcional).
  \item \texttt{--auth-guard}: Define o tipo de autenticação: \texttt{session}, \texttt{access\_tokens} ou \texttt{basic\_auth}.
\end{itemize}

\subsection{Exemplos práticos}

\begin{examplebox}
  Criar um projeto básico, perguntando todas as opções:
\end{examplebox}

\lstinputlisting[
  language=bash,
  caption={Criando um novo projeto AdonisJS},
  label={lst:adonis_new_project_basic}
]{snippets/primeiros-passos/adonis_new_project_basic.sh}

\begin{examplebox}
  Criar um projeto API usando PostgreSQL:
\end{examplebox}

\lstinputlisting[
  language=bash,
  caption={Projeto API com PostgreSQL},
  label={lst:adonis_new_project_api_postgres}
]{snippets/primeiros-passos/adonis_new_project_api_postgres.sh}

\begin{examplebox}
  Criar um projeto Web com MySQL:
\end{examplebox}

\lstinputlisting[
  language=bash,
  caption={Projeto Web com MySQL},
  label={lst:adonis_new_project_web_mysql}
]{snippets/primeiros-passos/adonis_new_project_web_mysql.sh}

\begin{examplebox}
  Criar um projeto com autenticação baseada em tokens:
\end{examplebox}

\lstinputlisting[
  language=bash,
  caption={Projeto API com guard de autenticação por tokens},
  label={lst:adonis_new_project_api_tokens}
]{snippets/primeiros-passos/adonis_new_project_api_tokens.sh}

\subsection{Escolhendo o Starter Kit}

O AdonisJS oferece quatro tipos principais de starter kits, cada um pensado para um tipo de projeto:

\begin{description}
  \item[\textbf{Web}] Para aplicações que renderizam HTML no backend usando EdgeJS.
  \item[\textbf{API}] Ideal para backends que servem dados em JSON (para apps mobile, frontend em React, Vue, etc.).
  \item[\textbf{Slim}] Uma versão mínima do framework, sem ORM, sem autenticação e sem templates.
  \item[\textbf{Inertia}] Para quem deseja construir SPAs server-driven, usando React, Vue, Solid ou Svelte no frontend.
\end{description}

\begin{tipbox}
  Se sua aplicação não precisa de um frontend robusto, o kit \texttt{web} oferece extrema produtividade utilizando apenas EdgeJS para renderização no servidor.
\end{tipbox}

\subsection{Iniciando o servidor de desenvolvimento}

Após criar o projeto, execute o servidor com:

\lstinputlisting[
  language=bash,
  caption={Iniciando o servidor},
  label={lst:server_start}
]{snippets/primeiros-passos/server_start.sh}

Acesse no navegador:

\lstinputlisting[
  language=bash,
  caption={URL local da aplicação},
  label={lst:open_localhost}
]{snippets/primeiros-passos/open_localhost.txt}

\subsection{Build para produção}

Compile sua aplicação para produção com:

\lstinputlisting[
  language=bash,
  caption={Gerando build de produção},
  label={lst:build_production}
]{snippets/primeiros-passos/build_production.sh}

O código será gerado na pasta \texttt{build/} e está pronto para ser executado com Node.js.

\subsection{Configurando o ambiente de desenvolvimento}

O projeto já vem com \texttt{ESLint} e \texttt{Prettier} configurados com os padrões recomendados pela equipe do AdonisJS.

\lstinputlisting[
  language=bash,
  caption={Executando ferramentas de lint e format},
  label={lst:lint_format}
]{snippets/primeiros-passos/lint_format.sh}

\begin{tipbox}
  Recomendo instalar as extensões do AdonisJS, EdgeJS e Japa para VSCode. Elas oferecem recursos como:
  \begin{itemize}
    \item Highlight e snippets.
    \item Rodar comandos Ace direto do VSCode.
    \item Visualizar rotas e migrations.
  \end{itemize}
\end{tipbox}

\section{Primeiro Projeto}

Ao criar um projeto com AdonisJS, você não está apenas iniciando um backend. Você está construindo uma aplicação com uma arquitetura sólida, uma base fortemente tipada e uma série de ferramentas integradas que tornam o desenvolvimento muito mais produtivo.

Depois de executar:

\lstinputlisting[
  language=bash,
  caption={Criando o projeto},
  label={lst:adonis_new_project_basic}
]{snippets/primeiros-passos/adonis_new_project_basic.sh}

E rodar:

\lstinputlisting[
  language=bash,
  caption={Iniciando o servidor},
  label={lst:server_start}
]{snippets/primeiros-passos/server_start.sh}

Você verá sua aplicação rodando em:

\lstinputlisting[
  language=bash,
  caption={URL local da aplicação},
  label={lst:open_localhost}
]{snippets/primeiros-passos/open_localhost.txt}

Por padrão, o projeto já vem com:

\begin{itemize}
  \item Uma API pronta (se você escolheu o kit \texttt{api}).
  \item Estrutura MVC bem definida.
  \item Gerenciamento de banco com Lucid ORM.
  \item Sistema de autenticação (se escolhido).
  \item Validações robustas com VineJS.
  \item Logs, tratamento de erros, middlewares e muito mais.
\end{itemize}

\begin{infobox}
  O projeto já está totalmente funcional após o primeiro comando. O AdonisJS gera uma estrutura produtiva desde o primeiro momento, permitindo que você foque no que realmente importa: as regras de negócio.
\end{infobox}

\section{Estrutura de Diretórios}

\begin{tipbox}
  O AdonisJS oferece uma estrutura de diretórios opinativa, pensada para escalar e manter sua aplicação organizada. Entretanto, você tem total liberdade para ajustá-la conforme as necessidades do seu projeto.
\end{tipbox}

A seguir, uma visão geral da estrutura padrão:

\lstinputlisting[
  language=bash,
  caption={Estrutura de Diretórios},
  label={lst:project_structure}
]{snippets/primeiros-passos/project_structure.txt}

\subsection*{Principais Diretórios}

\begin{description}
  \item[\textbf{app/}] Onde vive sua lógica de negócio. Controllers, Models, Services, Validators, Middlewares, Listeners e Events.
  \item[\textbf{config/}] Arquivos de configuração (banco, cache, autenticação, etc.).
  \item[\textbf{start/}] Arquivos carregados na inicialização da aplicação (\texttt{routes.ts}, \texttt{kernel.ts}, \texttt{events.ts}, \texttt{env.ts}).
  \item[\textbf{resources/}] Views EdgeJS e assets do frontend.
  \item[\textbf{database/}] Migrations e Seeders.
  \item[\textbf{providers/}] Service Providers para extender funcionalidades do framework.
  \item[\textbf{types/}] Arquivos TypeScript para contratos e definições de tipos.
  \item[\textbf{public/}] Arquivos estáticos acessíveis externamente (\texttt{/style.css} → \url{http://localhost:3333/style.css}).
\end{description}

\begin{examplebox}
  O arquivo \texttt{start/routes.ts} é onde você define suas rotas HTTP.
  O \texttt{app/controllers/} guarda os controllers que recebem essas requisições.
  O \texttt{app/services/} pode ser usado para regras de negócio mais complexas.
\end{examplebox}

\section{Ambiente e Configurações}

A configuração no AdonisJS é simples, escalável e baseada em dois pilares fundamentais:

\begin{itemize}
  \item Arquivos dentro da pasta \texttt{config/}.
  \item Variáveis de ambiente (\texttt{.env}).
\end{itemize}

\subsection{Configurações do Projeto}

Todos os arquivos da pasta \texttt{config/} são módulos TypeScript e podem ser importados diretamente:

\lstinputlisting[
  language=TypeScript,
  caption={Importando diretamente},
  label={lst:config_import_direct}
]{snippets/primeiros-passos/import_config_direct.ts}

Ou, de forma dinâmica, utilizando o \texttt{config service}:

\lstinputlisting[
  language=TypeScript,
  caption={Acessando via Config Service},
  label={lst:config_service_access}
]{snippets/primeiros-passos/config_service_access.ts}

\begin{tipbox}
  Usar o \texttt{config service} permite acessar as configurações dentro de Providers, Edge Templates e ambientes onde importações diretas não funcionam.
\end{tipbox}

\subsection{Variáveis de Ambiente}

O arquivo \texttt{start/env.ts} controla as variáveis de ambiente, valida suas existências e tipos:

\lstinputlisting[
  language=TypeScript,
  caption={Exemplo básico de env.ts},
  label={lst:env_ts_example}
]{snippets/primeiros-passos/env_ts_example.ts}

O \texttt{env.get()} é utilizado para acessar os valores:

\lstinputlisting[
  language=TypeScript,
  caption={Lendo valores do .env},
  label={lst:env_read_values}
]{snippets/primeiros-passos/env_read_values.ts}

\begin{warningbox}
  Se uma variável não estiver declarada no arquivo \texttt{start/env.ts}, o AdonisJS acusará erro de boot — isso garante segurança e previsibilidade.
\end{warningbox}

\subsection{Estrutura do .env}

\lstinputlisting[
  language=bash,
  caption={Exemplo de .env},
  label={lst:dotenv_example}
]{snippets/primeiros-passos/dotenv_example.env}

\subsection{Configurações no Edge Templates}

\lstinputlisting[
  language=html,
  caption={Utilizando config e env nas views},
  label={lst:edge_config_env}
]{snippets/primeiros-passos/edge_config_env.edge}

\begin{infobox}
  O acesso a variáveis no Edge é restrito ao server-side. Nenhuma informação sensível vaza para o cliente.
\end{infobox}

\subsection{Alterando Configuração em Tempo de Execução}

Você pode alterar valores durante a execução:

\lstinputlisting[
  language=TypeScript,
  caption={Alterando valor de configuração em tempo de execução},
  label={lst:config_runtime_set}
]{snippets/primeiros-passos/config_runtime_set.ts}

\begin{warningbox}
  Essa alteração é feita apenas em memória, válida para toda a instância da aplicação até ser reiniciada. Isso não altera os arquivos no disco.
\end{warningbox}

\begin{tipbox}
  Boas práticas:
  \begin{itemize}
    \item Nunca versionar arquivos \texttt{.env} em repositórios públicos.
    \item Utilizar chaves seguras para \texttt{APP\_KEY} e senhas de banco.
    \item Configurar múltiplos arquivos \texttt{.env} para ambientes diferentes: \texttt{.env.development.local}, \texttt{.env.production}.
  \end{itemize}
\end{tipbox}

\chapter{Conceitos Fundamentais}

\section{Ciclo de Vida da Aplicação}

O ciclo de vida da aplicação no AdonisJS define todas as etapas desde a inicialização até o encerramento da aplicação. Compreender esse ciclo é fundamental para estruturar corretamente Service Providers, configuração, eventos e qualquer funcionalidade que dependa da ordem de carregamento dos componentes.

\subsection{Visão Geral do Ciclo de Vida}

Ao executar uma aplicação AdonisJS, ela passa por um pipeline bem definido de estados, que varia de acordo com o ambiente (\textit{web}, \textit{console}, \textit{test} ou \textit{repl}). Cada estado libera determinados recursos, como container, providers, serviços e eventos.

As principais fases são:

\begin{itemize}
  \item \textbf{Created}: Estado inicial da aplicação, imediatamente após a criação da instância da classe \texttt{Application}.

  \item \textbf{Initiated}: Ocorre após a leitura do arquivo \texttt{adonisrc.ts} e validação das variáveis de ambiente.

  \item \textbf{Booted}: Todos os Service Providers foram registrados e executaram seus métodos \texttt{register()} e \texttt{boot()}. O container está pronto para fornecer dependências.

  \item \textbf{Ready}: A aplicação está pronta para processar requisições HTTP, executar comandos ou rodar testes, dependendo do ambiente.

  \item \textbf{Terminating}: Estado transitório iniciado quando ocorre um sinal de término (\texttt{SIGTERM}, \texttt{SIGINT} ou falha do servidor). Usado para encerramento controlado, como fechar conexões e liberar recursos.

  \item \textbf{Terminated}: A aplicação encerrou completamente e os recursos foram liberados.
\end{itemize}

\subsection{Entrypoints da Aplicação}

Os pontos de entrada da aplicação estão localizados no diretório \texttt{bin/}, cada um responsável por um ambiente:

\begin{itemize}
  \item \texttt{bin/server.ts}: Inicia o servidor HTTP (\texttt{node ace serve}).
  \item \texttt{bin/console.ts}: Executa comandos via CLI (\texttt{node ace ...}).
  \item \texttt{bin/test.ts}: Executa os testes com Japa.
\end{itemize}

Todos esses arquivos utilizam o módulo \texttt{Ignitor}, que executa três passos:

\begin{enumerate}
  \item Cria uma instância da classe \texttt{Application}.
  \item Inicializa (\textit{boot}) a aplicação e os Service Providers.
  \item Executa a ação principal, como iniciar o servidor HTTP, rodar testes ou comandos.
\end{enumerate}

\subsection{Fases do Lifecycle}

O ciclo de vida é dividido nas seguintes fases, com hooks específicos:

\begin{itemize}
  \item \textbf{Initiating}: Antes da leitura do arquivo \texttt{adonisrc.ts}.

  \item \textbf{Booting}: Antes da execução dos métodos \texttt{register()} e \texttt{boot()} dos Service Providers.

  \item \textbf{Booted}: Após todos os providers serem registrados e inicializados.

  \item \textbf{Starting}: Antes de carregar arquivos de preload e antes da aplicação estar pronta.

  \item \textbf{Ready}: Após a aplicação estar totalmente pronta, seja para aceitar requisições HTTP, executar comandos ou rodar testes.

  \item \textbf{Terminating}: Quando o processo inicia o encerramento (\texttt{SIGTERM}, \texttt{SIGINT}).
\end{itemize}

\subsection{Lifecycle por Ambiente}

\begin{description}
  \item[Web] Mantém a aplicação no estado \textit{Ready} enquanto o servidor HTTP estiver rodando. A terminação ocorre por erro, \texttt{SIGINT} ou \texttt{SIGTERM}.

  \item[Test] Executa as fases \texttt{pre-start} e \texttt{post-start}, roda os testes, e após, inicia a terminação.

  \item[Console] O comando define se a aplicação será iniciada. É possível controlar se o app fica vivo (\texttt{staysAlive}) e se deve iniciar o ciclo completo (\texttt{startApp}).

  \item[REPL] Inicializa como console, mas muda o ambiente internamente para \texttt{repl} após o carregamento inicial.
\end{description}

\subsection{Lifecycle Hooks}

O AdonisJS fornece hooks para executar funções durante as transições de estado. Esses hooks podem ser definidos:

\begin{itemize}
  \item Diretamente no código (\texttt{app.booted()}, \texttt{app.ready()}, \texttt{app.terminating()}).
  \item Dentro de Service Providers, usando os métodos:
        \begin{itemize}
          \item \texttt{register()}
          \item \texttt{boot()}
          \item \texttt{start()}
          \item \texttt{ready()}
          \item \texttt{shutdown()}
        \end{itemize}
\end{itemize}

\subsection{Respondendo a Sinais do Sistema}

A aplicação responde a sinais POSIX como:

\begin{itemize}
  \item \texttt{SIGTERM} – sinal de encerramento padrão.
  \item \texttt{SIGINT} – encerramento via terminal (Ctrl+C).
\end{itemize}

É possível escutar esses sinais:

\lstinputlisting[
  language=TypeScript,
  caption={Escutando SIGTERM para encerramento gracioso},
  label={lst:app_sigterm}
]{snippets/conceitos-fundamentais/app_signal_sigterm.ts}

\subsection{Estados da Aplicação}

Os estados da aplicação podem ser consultados em tempo de execução:

\lstinputlisting[
  language=TypeScript,
  caption={Consultando estados da aplicação},
  label={lst:app_states}
]{snippets/conceitos-fundamentais/app_states.ts}

\subsection{Estrutura do Arquivo \texttt{adonisrc.ts}}

O arquivo \texttt{adonisrc.ts} define a configuração global da aplicação, incluindo:

\begin{itemize}
  \item Diretórios (\texttt{app/}, \texttt{config/}, \texttt{providers/}, etc.).
  \item Service Providers utilizados.
  \item Arquivos de preload.
  \item Metadados e aliases de comandos.
  \item Configuração dos testes.
\end{itemize}

Exemplo simplificado:

\lstinputlisting[
  language=TypeScript,
  caption={Exemplo simplificado de \texttt{adonisrc.ts}},
  label={lst:adonisrc_example}
]{snippets/conceitos-fundamentais/adonisrc_example.ts}

O ciclo de vida da aplicação no AdonisJS permite um controle refinado de como e quando os componentes da aplicação são carregados, inicializados, disponibilizados e encerrados. Entender esse fluxo é essencial para implementar corretamente Service Providers, middlewares, jobs, tasks e garantir que sua aplicação seja robusta, escalável e mantenha a integridade dos recursos utilizados.

\section{Service Providers}

Os \textit{Service Providers} são o coração do AdonisJS e representam o principal ponto de extensão e configuração da aplicação. Eles são responsáveis por registrar dependências, inicializar serviços, executar código durante o ciclo de vida da aplicação e ampliar as funcionalidades do framework.

\subsection{O que são Service Providers}

Um \textit{Service Provider} é uma classe que contém métodos especiais chamados de \textbf{lifecycle hooks}, que são executados em momentos específicos do ciclo de vida da aplicação.

Eles são usados para:

\begin{itemize}
  \item Registrar dependências no container de IoC.
  \item Inicializar serviços ou estender funcionalidades.
  \item Executar ações antes ou depois da aplicação estar pronta.
  \item Realizar tarefas de encerramento (graceful shutdown).
\end{itemize}

Eles são fundamentais tanto no desenvolvimento da sua própria aplicação quanto na criação de pacotes externos.

\subsection{Registro de Providers}

Os providers são registrados no arquivo \texttt{adonisrc.ts}, dentro da propriedade \texttt{providers}:

\lstinputlisting[
  language=TypeScript,
  caption={Registrando providers no \texttt{adonisrc.ts}},
  label={lst:adonisrc_providers_basic}
]{snippets/conceitos-fundamentais/adonisrc_providers_basic.ts}

Também é possível restringir o provider para rodar apenas em determinados ambientes:

\lstinputlisting[
  language=TypeScript,
  caption={Provider limitado por ambientes},
  label={lst:adonisrc_providers_env}
]{snippets/conceitos-fundamentais/adonisrc_providers_env.ts}

\subsection{Estrutura de um Service Provider}

Um provider é uma classe TypeScript (ou JavaScript) exportada como \texttt{default} e que implementa métodos específicos.

\lstinputlisting[
  language=TypeScript,
  caption={Estrutura mínima de um Service Provider},
  label={lst:provider_skeleton}
]{snippets/conceitos-fundamentais/provider_skeleton.ts}

\subsection{Ciclo de Vida dos Providers}

Cada método do provider é executado em uma fase específica do ciclo da aplicação:

\begin{description}
  \item[\textbf{register()}] Método síncrono. Usado para registrar dependências no container. Não é possível acessar serviços que dependem de async neste momento.

  \item[\textbf{boot()}] Executado após todos os \texttt{register()}. Aqui você pode acessar e modificar serviços já registrados, além de adicionar macros, regras de validação ou estender funcionalidades.

  \item[\textbf{start()}] Executado antes de \texttt{ready()}. Serve para executar inicializações necessárias para o funcionamento completo da aplicação.

  \item[\textbf{ready()}] Executado quando a aplicação está totalmente pronta. No ambiente web, isso ocorre após o servidor HTTP estar ouvindo requisições; no ambiente console, antes da execução dos comandos; nos testes, antes de rodar os testes; e no REPL, antes de abrir o prompt.

  \item[\textbf{shutdown()}] Executado no processo de encerramento (\textit{graceful shutdown}). Usado para fechar conexões, encerrar processos ou limpar recursos.
\end{description}

\subsection{Exemplos Práticos}

\subsubsection{Registrando uma dependência no container}

\lstinputlisting[
  language=TypeScript,
  caption={Registrando binding \texttt{db} no container},
  label={lst:provider_db_bind}
]{snippets/conceitos-fundamentais/provider_db_bind.ts}

\subsubsection{Estendendo o Validator com uma regra personalizada}

\lstinputlisting[
  language=TypeScript,
  caption={Adicionando regra \texttt{cpf} ao Validator no \texttt{boot()}},
  label={lst:provider_validator_rule_cpf}
]{snippets/conceitos-fundamentais/provider_validator_rule_cpf.ts}

\subsubsection{Respondendo ao ambiente no start()}

\lstinputlisting[
  language=TypeScript,
  caption={Logs condicionais por ambiente no \texttt{start()}},
  label={lst:provider_start_env_log}
]{snippets/conceitos-fundamentais/provider_start_env_log.ts}

\subsubsection{Encerrando conexões no shutdown()}

\lstinputlisting[
  language=TypeScript,
  caption={Fechando conexão com banco no \texttt{shutdown()}},
  label={lst:provider_shutdown_close_db}
]{snippets/conceitos-fundamentais/provider_shutdown_close_db.ts}

\subsection{Extensão do Framework}

Além de registrar e inicializar serviços, providers são usados para \textbf{extender o próprio AdonisJS}. Isso é feito através de:

\begin{itemize}
  \item \textbf{Macros}: adicionam métodos nas classes.
  \item \textbf{Getters}: adicionam propriedades computadas.
\end{itemize}

\subsubsection{Exemplo de Macro}

\lstinputlisting[
  language=TypeScript,
  caption={Macro \texttt{wantsJSON} em \texttt{Request}},
  label={lst:request_macro_wants_json}
]{snippets/conceitos-fundamentais/request_macro_wants_json.ts}

\textbf{Uso no código:}

\lstinputlisting[
  language=TypeScript,
  caption={Uso de \texttt{request.wantsJSON()}},
  label={lst:use_request_wants_json}
]{snippets/conceitos-fundamentais/use_request_wants_json.ts}

\subsubsection{Exemplo de Getter}

\lstinputlisting[
  language=TypeScript,
  caption={Getter \texttt{hasRequestId} em \texttt{Request}},
  label={lst:request_getter_has_request_id}
]{snippets/conceitos-fundamentais/request_getter_has_request_id.ts}

\textbf{Uso:}

\lstinputlisting[
  language=TypeScript,
  caption={Uso de \texttt{request.hasRequestId}},
  label={lst:use_request_has_request_id}
]{snippets/conceitos-fundamentais/use_request_has_request_id.ts}

\subsection{Classes que Suportam Macros e Getters}

\begin{itemize}
  \item \texttt{Application}
  \item \texttt{Request}
  \item \texttt{Response}
  \item \texttt{HttpContext}
  \item \texttt{Route}, \texttt{RouteGroup}, \texttt{RouteResource}, \texttt{BriskRoute}
  \item \texttt{ExceptionHandler}
  \item \texttt{MultipartFile}
\end{itemize}

\subsection{Quando Usar Service Providers}

\begin{itemize}
  \item Sempre que criar serviços que precisam ser globais para sua aplicação.
  \item Quando for necessário estender funcionalidades do framework (Request, Response, Validator, etc.).
  \item Na criação de pacotes, bibliotecas internas ou APIs para sua empresa.
  \item Para inicializar conexões, carregar configurações complexas, agendar tarefas ou ouvir eventos.
\end{itemize}

\section{IoC Container e Dependency Injection}

O \textit{IoC Container} do AdonisJS é o núcleo de composição da aplicação. Ele centraliza a criação/configuração de objetos, evitando \textit{boilerplate} e promovendo baixo acoplamento. Nesta seção, vamos entender como o container funciona, como usar \textit{Dependency Injection} (DI), quando preferir \textit{Container Services} e como o \textit{Async Local Storage} (ALS) fornece um escopo de requisição para isolar contexto.

\subsection{Por que um IoC Container?}

Sem um container, cada uso de uma classe exigiria inicialização manual e passagem de dependências (config, logger, conexões, etc.). Isso polui o código e torna difícil padronizar a criação de objetos.

\begin{examplebox}
  \textbf{Sem container} (inicialização manual):
  \lstinputlisting[
    language=TypeScript,
    caption={Inicialização manual de \texttt{Database} sem container},
    label={lst:db_manual_init}
  ]{snippets/conceitos-fundamentais/db_manual_init.ts}

  \textbf{Com container} (instância pré-configurada):
  \lstinputlisting[
    language=TypeScript,
    caption={Resolvendo \texttt{lucid.db} via container},
    label={lst:db_container_make}
  ]{snippets/conceitos-fundamentais/db_container_make.ts}
\end{examplebox}

\begin{infobox}
  Ao delegar ao container a construção das instâncias, você mantém a base coesa e consistente, sem código repetitivo de inicialização.
\end{infobox}

\subsection{Container Services: um atalho idiomático}

Chamar \texttt{app.container.make(...)} funciona, mas tem inconvenientes editoriais e de legibilidade. Para resolver, os pacotes expõem \textit{Container Services}: módulos que encapsulam a resolução via container e permitem \texttt{import} direto.

\begin{examplebox}
  \textbf{Sem service} (chamada explícita ao container):
  \lstinputlisting[
    language=TypeScript,
    caption={Resolvendo \texttt{lucid.db} via container},
    label={lst:db_container_make_again}
  ]{snippets/conceitos-fundamentais/db_container_make.ts}

  \textbf{Com service} (import direto):
  \lstinputlisting[
    language=TypeScript,
    caption={Importando \texttt{db} via Container Service},
    label={lst:db_service_import}
  ]{snippets/conceitos-fundamentais/db_service_import.ts}
\end{examplebox}

\begin{warningbox}
  \texttt{container.make} não se beneficia de auto-imports do editor; já os \textit{services} funcionam como qualquer módulo, melhorando a DX.
\end{warningbox}

\subsection{Dependency Injection (DI) no AdonisJS}

A DI cria um acoplamento frouxo: em vez de buscar uma dependência, o objeto a recebe no construtor. No AdonisJS, você pode usar o decorador \texttt{@inject()} para pedir que o container resolva as dependências.

\lstinputlisting[
  language=TypeScript,
  caption={Injetando \texttt{Disk} com \texttt{@inject()}},
  label={lst:inject_disk}
]{snippets/conceitos-fundamentais/post_service_di.ts}

\subsection{Container Services \textit{vs.} Dependency Injection}

\begin{description}
  \item[\textbf{Container Services}] Código mais conciso: você importa um service (ex.: \texttt{drive}) e obtém a instância que precisa (ex.: \texttt{drive.use('s3')}).
  \item[\textbf{Dependency Injection}] Desacoplamento explícito e testabilidade por construção: a classe declara o que precisa e recebe pelo construtor.
\end{description}

\begin{examplebox}
  \textbf{Usando service} (conciso e direto):
  \lstinputlisting[
    language=TypeScript,
    caption={Obtendo instância via \texttt{Container Service}},
    label={lst:service_use}
  ]{snippets/conceitos-fundamentais/post_service_service.ts}
\end{examplebox}

\begin{tipbox}
  Escolher um ou outro é questão de estilo arquitetural. Em domínios complexos (vários mocks/stubs), DI brilha; em casos simples, \textit{services} agilizam.
\end{tipbox}

\subsection{Testes com Container Services}

DI facilita trocar dependências nos testes. Para experiências similares com \textit{services}, o AdonisJS fornece APIs de \textit{fake}.

\lstinputlisting[
  language=TypeScript,
  caption={Trocando \texttt{disk} por \textit{fake} em testes},
  label={lst:drive_fake}
]{snippets/conceitos-fundamentais/drive_fake_test.ts}

\begin{infobox}
  Fakes permitem validar comportamento sem I/O real (ex.: sem subir S3), mantendo testes rápidos e determinísticos.
\end{infobox}

\subsection{Bindings e services mais comuns}

A seguir, alguns bindings do container e seus \textit{services} correspondentes:

\begin{itemize}
  \item \textbf{app}: \verb|@adonisjs/core/services/app|
  \item \textbf{ace}: \verb|@adonisjs/core/services/kernel|
  \item \textbf{config}: \verb|@adonisjs/core/services/config|
  \item \textbf{encryption}: \verb|@adonisjs/core/services/encryption|
  \item \textbf{emitter}: \verb|@adonisjs/core/services/emitter|
  \item \textbf{hash}: \verb|@adonisjs/core/services/hash|
  \item \textbf{logger}: \verb|@adonisjs/core/services/logger|
  \item \textbf{router}: \verb|@adonisjs/core/services/router|
  \item \textbf{server}: \verb|@adonisjs/core/services/server|
  \item \textbf{testUtils}: \verb|@adonisjs/core/services/test_utils|
\end{itemize}

\subsection{Service Providers (registrando no container)}

\textit{Service Providers} são classes com métodos de ciclo de vida para registrar/estender bindings, executar ações de \textit{boot/start/ready} e reagir ao encerramento. Eles são referenciados em \texttt{adonisrc.ts} no array \texttt{providers} e podem ser escopados por ambiente.

\lstinputlisting[
  language=TypeScript,
  caption={Ex.: provider mínimo com \texttt{register}/\texttt{boot}},
  label={lst:provider_minimo}
]{snippets/conceitos-fundamentais/provider_minimo.ts}

\begin{tipbox}
  Use providers para “plug-ins de aplicação”: registrar bindings, estender validação, ligar observabilidade, etc. Para injeção pontual em uma classe, prefira DI.
\end{tipbox}

\subsection{Async Local Storage (ALS) e escopo de requisição}

O AdonisJS usa \textbf{Async Local Storage} para isolar dados por requisição. Isso permite recuperar o \textit{contexto} (\texttt{HttpContext}) em qualquer parte do fluxo assíncrono, sem repassar variáveis manualmente.

\lstinputlisting[
  language=TypeScript,
  caption={Acessando o contexto atual via ALS},
  label={lst:als_request_id}
]{snippets/conceitos-fundamentais/als_request_id.ts}

\begin{infobox}
  Com ALS, cada requisição tem seu próprio “universo” assíncrono. Logs, métricas e \textit{tracing} podem incluir \texttt{requestId} sem poluir assinaturas de funções.
\end{infobox}

\begin{warningbox}
  O acesso ao container/serviços depende do estado da aplicação. Antes do \textbf{boot}, bindings não estão disponíveis. Utilize \texttt{app.isBooted}, \texttt{app.isReady} e os hooks de lifecycle para sincronizar ações.
\end{warningbox}

\subsection{Ambientes, estados e utilitários da \texttt{Application}}

A classe \texttt{Application} expõe o \textbf{ambiente} (web/console/test/repl), o \textbf{estado} (created/initiated/booted/ready/terminated), utilitários de caminho (ex.: \texttt{configPath()}, \texttt{migrationsPath()}, \texttt{viewsPath()}) e sinais de processo.

\lstinputlisting[
  language=TypeScript,
  caption={Consultando ambiente/estado e usando paths},
  label={lst:app_env_paths}
]{snippets/conceitos-fundamentais/app_env_paths.ts}

\begin{examplebox}
  \textbf{Sinais de processo} (graceful shutdown):
  \lstinputlisting[
    language=TypeScript,
    caption={Escutando \texttt{SIGTERM} para encerramento gracioso},
    label={lst:app_sigterm_box}
  ]{snippets/conceitos-fundamentais/app_signal_sigterm.ts}
\end{examplebox}

\subsection{Resumo prático}

\begin{itemize}
  \item Use \textbf{Container Services} para código conciso e melhor DX (\texttt{import db from ...}).
  \item Prefira \textbf{DI} quando precisar de mocks/stubs fáceis e baixo acoplamento explícito.
  \item \textbf{Fakes} de services viabilizam testes rápidos sem I/O real.
  \item \textbf{ALS} fornece escopo por requisição: recupere \texttt{HttpContext} sem repasse manual.
  \item \textbf{Providers} registram/estendem bindings e se integram ao lifecycle.
\end{itemize}



\section{Configuração e Arquivos de Ambiente}

O sistema de configuração do AdonisJS é baseado em módulos dentro de \texttt{config/} e no uso de variáveis de ambiente declaradas/validadas em \texttt{start/env.ts}. Além disso, o arquivo \texttt{.adonisrc.ts} (ou \texttt{.adonisrc.json} em projetos legados) define metadados do workspace, \textit{providers}, \textit{preloads}, \textit{metaFiles} e ajustes de diretórios.

\subsection{Configuração em \texttt{config/} e variáveis \texttt{.env}}

Cada arquivo em \texttt{config/} exporta a configuração de um subsistema (banco, hash, cache, etc.). Esses módulos podem ser importados diretamente ou acessados via \texttt{config service}. Os valores vêm do \texttt{.env}, validados por \texttt{start/env.ts}. Isso garante previsibilidade: se uma variável exigida não existir ou não passar na validação, a aplicação nem \textit{boota}.

\begin{tipbox}
  Boas práticas: manter \texttt{.env} fora do versionamento; usar chaves fortes; separar \texttt{.env} por ambiente (ex.: \texttt{.env.development.local}, \texttt{.env.production}); centralizar validações em \texttt{start/env.ts}.
\end{tipbox}

\subsection{Config Providers}

Alguns arquivos em \texttt{config/} (como \texttt{config/hash.ts}) não exportam um objeto simples; eles usam \textbf{config providers} para adiar a computação da configuração até depois que a aplicação foi \textit{bootada}, quando o container já está disponível.

\subsubsection{Sem config provider (conceito ilustrativo).}
Se não houvesse \textit{provider}, você teria que instanciar \texttt{Scrypt} diretamente (e possivelmente suas dependências):

\lstinputlisting[
  language=TypeScript,
  caption={Hash sem provider (ilustrativo)},
  label={lst:hash_without_provider}
]{snippets/conceitos-fundamentais/hash_without_provider.ts}

Se o driver precisasse do \texttt{Emitter} (para emitir eventos), tentar resolvê-lo via service antes do \textit{boot} falharia, pois os services do container não estão prontos quando os arquivos de \texttt{config/} são importados.

\begin{warningbox}
  Importar services do container dentro de arquivos \texttt{config/*} antes do \textbf{boot} resulta em erro, pois o container ainda não está disponível nesse momento.
\end{warningbox}

Uma saída seria instanciar manualmente o \texttt{Emitter} e reaproveitá-lo, mas isso adiciona \textit{boilerplate} e “quebra” a centralização de dependências no container.

\subsubsection{Com config provider (recomendado).}
O \textbf{config provider} é uma função que recebe a \texttt{Application} e resolve dependências pelo container no momento certo. Assim, você só constrói o driver quando alguém usa o serviço (ex.: \texttt{hash}):

\lstinputlisting[
  language=TypeScript,
  caption={Hash com \texttt{configProvider}},
  label={lst:hash_config_provider}
]{snippets/conceitos-fundamentais/hash_config_provider.ts}

\begin{infobox}
  Com \textit{config providers}, dependências são resolvidas somente quando o serviço é utilizado, evitando acesso prematuro ao container e reduzindo \textit{boilerplate}.
\end{infobox}

\subsubsection{Como acesso a configuração resolvida?}
Os serviços expõem a configuração efetiva. Exemplo com \texttt{hash}:

\lstinputlisting[
  language=TypeScript,
  caption={Lendo config resolvida do serviço},
  label={lst:hash_read_config}
]{snippets/conceitos-fundamentais/hash_read_config.ts}

\subsection{Arquivos \texttt{.env} e \texttt{start/env.ts}}

O arquivo \texttt{start/env.ts} valida e tipa as variáveis de ambiente. Em runtime, você as lê por \texttt{env.get('CHAVE')}. Variáveis ausentes/invalidas fazem o \textit{boot} falhar — intencional para segurança e previsibilidade.

\begin{warningbox}
  Se uma variável necessária não estiver declarada/validada em \texttt{start/env.ts}, a aplicação falha no \textit{boot}. Corrija \texttt{.env} e/ou o schema no \texttt{env.ts}.
\end{warningbox}

\subsection{\texttt{.adonisrc.ts} (ou \texttt{.adonisrc.json} legado)}

O \texttt{.adonisrc.ts} define as configurações de workspace: \textit{providers}, \textit{preloads}, \textit{metaFiles}, \textit{commands}, \textit{directories}, \textit{tests} e mais. Ele é importado por ferramentas fora do ciclo normal da aplicação; portanto, não inclua nele código específico de \textit{runtime} ou condicionais de ambiente.

\lstinputlisting[
  language=bash,
  caption={Inspecionando o RC file},
  label={lst:inspect_rcfile}
]{snippets/conceitos-fundamentais/inspect_rcfile.sh}

Você pode ler o RC já parseado via \texttt{app.rcFile}:

\lstinputlisting[
  language=TypeScript,
  caption={Acessando RC com o \texttt{app} service},
  label={lst:app_rcfile_access}
]{snippets/conceitos-fundamentais/app_rcfile_access.ts}

\subsubsection{Diretórios.}
Mapeia as pastas usadas por \textit{scaffolding} e comandos:

\lstinputlisting[
  language=TypeScript,
  caption={Trecho de \texttt{.adonisrc.ts} - diretórios},
  label={lst:adonisrc_directories}
]{snippets/conceitos-fundamentais/adonisrc_directories.ts}

\subsubsection{Preloads.}
Arquivos importados logo após o \textit{boot} dos providers, com opção de restringir por ambiente:

\lstinputlisting[
  language=TypeScript,
  caption={Trecho de \texttt{.adonisrc.ts} - preloads},
  label={lst:adonisrc_preloads}
]{snippets/conceitos-fundamentais/adonisrc_preloads.ts}

\subsubsection{MetaFiles.}
Arquivos não TS/JS que devem ir para o \textit{build} (Edge, i18n, \texttt{public/**}):

\lstinputlisting[
  language=TypeScript,
  caption={Trecho de \texttt{.adonisrc.ts} - metaFiles},
  label={lst:adonisrc_metafiles}
]{snippets/conceitos-fundamentais/adonisrc_metafiles.ts}

\subsubsection{Commands e aliases.}
Registro \textit{lazy} de comandos e aliases memoráveis:

\lstinputlisting[
  language=TypeScript,
  caption={Trecho de \texttt{.adonisrc.ts} - commands/aliases},
  label={lst:adonisrc_commands_aliases}
]{snippets/conceitos-fundamentais/adonisrc_commands_aliases.ts}

\subsubsection{Tests.}
Configura suites e \textit{timeouts} do test runner:

\lstinputlisting[
  language=TypeScript,
  caption={Trecho de \texttt{.adonisrc.ts} - tests},
  label={lst:adonisrc_tests}
]{snippets/conceitos-fundamentais/adonisrc_tests.ts}

\subsubsection{Providers.}
Lista e ordena os \textit{service providers}, com possibilidade de limitar por ambiente:

\lstinputlisting[
  language=TypeScript,
  caption={Trecho de \texttt{.adonisrc.ts} - providers},
  label={lst:adonisrc_providers_full}
]{snippets/conceitos-fundamentais/adonisrc_providers_full.ts}

\subsubsection{Assets bundler.}
Se o \textit{auto-detect} do bundler não atender, defina como rodar \texttt{dev} e \texttt{build}:

\lstinputlisting[
  language=TypeScript,
  caption={Trecho de \texttt{.adonisrc.ts} - assetsBundler},
  label={lst:adonisrc_assets_bundler}
]{snippets/conceitos-fundamentais/adonisrc_assets_bundler.ts}

\begin{examplebox}
  \textbf{Fluxo recomendado}:
  \begin{enumerate}
    \item Declare e valide variáveis em \texttt{start/env.ts}.
    \item Leia-as em \texttt{config/*}, preferindo \textit{config providers} quando houver dependências do container.
    \item Organize \texttt{.adonisrc.ts} para refletir sua arquitetura: \textit{providers} na ordem correta, \textit{preloads} por ambiente, \textit{metaFiles} adequados e diretórios coerentes.
  \end{enumerate}
\end{examplebox}

\begin{infobox}
  \textbf{Resumo}: \texttt{config/} centraliza opções dos subsistemas; \texttt{.env}+\texttt{start/env.ts} garantem segurança e tipos; \textit{config providers} evitam acesso prematuro ao container; \texttt{.adonisrc.ts} descreve o workspace (providers, preloads, metaFiles, diretórios, testes e comandos).
\end{infobox}



\section{Ciclo HTTP e HttpContext}

O AdonisJS é, primariamente, um \textit{web framework}: ele inicializa um servidor HTTP, roteia requisições, aplica \textit{middlewares}, executa \textit{controllers}, trata exceções e serializa respostas. Nesta seção, detalhamos esse fluxo e o papel do \texttt{HttpContext} (ctx) como “porta-objetos” da requisição.

\subsection{Camada HTTP — visão geral}

A camada HTTP é composta por módulos construídos do zero (não há microframework oculto):

\begin{itemize}
  \item \textbf{Router}: define endpoints (rotas) e seus \textit{handlers} (closure ou método de controller).
  \item \textbf{Controllers}: classes que organizam a lógica de tratamento HTTP por recurso/ação.
  \item \textbf{HttpContext (ctx)}: criado \emph{por requisição}; contém \texttt{request}, \texttt{response}, usuário autenticado, etc.
  \item \textbf{Middleware}: \textit{pipeline} no padrão \textit{Chain of Responsibility} para interceptar/curtar o fluxo.
  \item \textbf{Global Exception Handler}: ponto único para transformar exceções em respostas e/ou reportá-las.
  \item \textbf{Server}: integra router, middlewares e exception handler e expõe o \texttt{handle} que o Node usa.
\end{itemize}

\begin{infobox}
  O \texttt{HttpContext} é efêmero e específico de cada requisição.
  Ele viaja por todo o ciclo: \textit{middlewares} (\(\rightarrow\)) rota/controller (\(\rightarrow\)) exception handler.
\end{infobox}

\subsection{Como o servidor HTTP inicia}

O servidor é preparado quando o \texttt{Server} executa \texttt{boot()} (disparado via Ignitor em \texttt{bin/server.ts}). Nessa fase, o framework:

\begin{itemize}
  \item Monta o \textit{pipeline} de \textbf{server middlewares}.
  \item Compila as \textbf{rotas}.
  \item Importa/instancia o \textbf{global exception handler}.
\end{itemize}

Rotas, \texttt{kernel} e handler global devem estar definidos antes do \textit{boot}; isso é feito via \texttt{start/routes.ts} e \texttt{start/kernel.ts} (preloads).

\subsection{Ciclo de uma requisição HTTP}

\begin{enumerate}
  \item \textbf{Criação do HttpContext}: ao chegar uma requisição, o servidor cria uma instância de \texttt{HttpContext} e a passa por referência a \textit{middlewares}, \textit{handlers} e exception handler. Se o \textit{AsyncLocalStorage} estiver habilitado, a mesma instância fica disponível no armazenamento local assíncrono.
  \item \textbf{Server middlewares}: executados sempre (mesmo sem rota correspondente), podendo responder antes de alcançar o handler.
  \item \textbf{Matching de rota}: se nada respondeu, procura-se uma rota para \texttt{req.url}. Sem correspondência, retorna 404.
  \item \textbf{Middlewares de rota}: executa globais do router e os nomeados da rota, ainda podendo encerrar o fluxo.
  \item \textbf{Handler da rota}: por fim, o \textit{handler} é invocado. Exceções em qualquer etapa são delegadas ao exception handler global.
  \item \textbf{Serialização da resposta}: com \texttt{response.send(...)} ou retorno de valor, o framework serializa o corpo e define cabeçalhos.
\end{enumerate}

\begin{warningbox}
  O \texttt{HttpContext} existe apenas durante o processamento da requisição. Não armazene referências dele em \textit{singletons} ou variáveis estáticas.
\end{warningbox}

\subsection{Acessando o HttpContext}

O \texttt{HttpContext} é o primeiro parâmetro de \textit{handlers}, métodos de \textit{controllers}, \textit{middlewares} e do exception handler global.

\subsubsection{Route handler (closure).}

\lstinputlisting[
  language=TypeScript,
  caption={Handler recebendo \texttt{ctx}},
  label={lst:handler_with_ctx}
]{snippets/conceitos-fundamentais/handler_with_ctx.ts}

\subsubsection{Desestruturando propriedades.}

\lstinputlisting[
  language=TypeScript,
  caption={Desestruturando \texttt{request} e \texttt{response}},
  label={lst:handler_destructure}
]{snippets/conceitos-fundamentais/handler_destructure.ts}

\subsubsection{Controller.}

\lstinputlisting[
  language=TypeScript,
  caption={Controller recebendo \texttt{HttpContext}},
  label={lst:controller_httpcontext}
]{snippets/conceitos-fundamentais/controller_httpcontext.ts}

\subsubsection{Middleware.}

\lstinputlisting[
  language=TypeScript,
  caption={Middleware com \texttt{next()}},
  label={lst:middleware_basic}
]{snippets/conceitos-fundamentais/middleware_basic.ts}

\subsubsection{Exception handler global.}

\lstinputlisting[
  language=TypeScript,
  caption={Exception handler global},
  label={lst:exception_handler}
]{snippets/conceitos-fundamentais/exception_handler.ts}

\subsection{Injetando HttpContext via Dependency Injection}

Se você usa \textit{DI}, pode declarar \texttt{HttpContext} como dependência (construtor ou método), e o container injeta o contexto da requisição em andamento. Garanta que o middleware \verb|#middleware/container_bindings_middleware| esteja registrado em \texttt{start/kernel.ts} para permitir \texttt{bindings} por requisição.

\lstinputlisting[
  language=TypeScript,
  caption={Injeção do \texttt{HttpContext} em service e controller},
  label={lst:di_inject_httpcontext}
]{snippets/conceitos-fundamentais/di_inject_httpcontext.ts}

\subsection{Acessando o contexto via Async Local Storage}

Você também pode recuperar o contexto em qualquer parte do código usando \texttt{AsyncLocalStorage} (exposto pelo framework):

\lstinputlisting[
  language=TypeScript,
  caption={Acessando \texttt{HttpContext} globalmente (ALS)},
  label={lst:als_get_context}
]{snippets/conceitos-fundamentais/als_get_context.ts}

\begin{tipbox}
  ALS evita “encadear” \texttt{ctx} manualmente por múltiplas camadas. Ainda assim, prefira DI quando quiser explicitar dependências e facilitar \textit{test doubles}.
\end{tipbox}

\subsection{Propriedades comuns do \texttt{ctx}}

Conforme você instala pacotes, novas propriedades podem ser adicionadas ao contexto. Algumas padrão:

\begin{itemize}
  \item \texttt{ctx.request}: requisição HTTP (corpo, headers, query).
  \item \texttt{ctx.response}: resposta HTTP (status, headers, \texttt{send}).
  \item \texttt{ctx.logger}: logger por requisição.
  \item \texttt{ctx.route}: rota correspondente; inclui metadados do \textit{match}.
  \item \texttt{ctx.params}: parâmetros dinâmicos da rota.
  \item \texttt{ctx.subdomains}: subdomínios da rota (quando aplicável).
  \item \texttt{ctx.session}: sessão da requisição (se habilitada).
  \item \texttt{ctx.auth}: autenticador (login/guards).
  \item \texttt{ctx.view}: renderizador Edge (SSR).
  \item \texttt{ctx.ally}: \textit{social login} (Ally).
  \item \texttt{ctx.bouncer}: autorização (políticas).
  \item \texttt{ctx.i18n}: internacionalização.
\end{itemize}

\subsection{Estendendo o HttpContext}

Você pode adicionar \textit{macros} e \textit{getters} ao contexto em runtime e, em seguida, declarar as tipagens via \textit{module augmentation}.

\lstinputlisting[
  language=TypeScript,
  caption={Macros e getters no \texttt{HttpContext}},
  label={lst:httpcontext_macros_getters}
]{snippets/conceitos-fundamentais/httpcontext_macros_getters.ts}

\begin{warningbox}
  Declare as tipagens (augmentation) para o TypeScript reconhecer os novos membros; sem isso, o projeto compila mas perde ajuda de tipos/autocompletar.
\end{warningbox}

\subsection{Criando \textit{dummy context} em testes}

Dentro de aplicações AdonisJS, use o service \verb|@adonisjs/core/services/test_utils| para criar um \texttt{HttpContext} falso:

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{testUtils.createHttpContext}},
  label={lst:testutils_create_httpcontext}
]{snippets/conceitos-fundamentais/testutils_create_httpcontext.ts}

Também é possível fornecer \texttt{req}/\texttt{res} personalizados:

\lstinputlisting[
  language=TypeScript,
  caption={Criando contexto com \texttt{req}/\texttt{res} personalizados},
  label={lst:testutils_custom_req_res}
]{snippets/conceitos-fundamentais/testutils_custom_req_res.ts}

Para pacotes externos (fora de apps AdonisJS), use a \texttt{HttpContextFactory}:

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{HttpContextFactory} para pacotes},
  label={lst:httpcontext_factory}
]{snippets/conceitos-fundamentais/httpcontext_factory.ts}

\begin{examplebox}
  \textbf{Resumo do ciclo}:
  \begin{enumerate}
    \item Servidor inicia e compila middlewares/rotas/handler global.
    \item Chega a requisição (\(\rightarrow\)) cria \texttt{ctx}.
    \item Executa server middlewares (\(\rightarrow\)) \textit{match} de rota.
    \item Executa middlewares da rota (\(\rightarrow\)) handler.
    \item Serializa resposta ou delega exceção ao handler global.
  \end{enumerate}
\end{examplebox}

\section{Ferramentas e Build do Ecossistema}

Esta seção reúne tópicos práticos do ecossistema: \textbf{HMR (Hot Module Replacement)} para ciclos de feedback rápidos no desenvolvimento; \textbf{processo de build TypeScript} para produção; \textbf{Scaffolding e Codemods} (geração e modificação de código); \textbf{Assembler Hooks} (pontos de extensão do processo de build/dev); e \textbf{aliases/paths} para importações limpas.

\subsection{Hot Module Replacement (HMR)}

O HMR recarrega módulos JavaScript alterados sem reiniciar todo o processo. No AdonisJS, o HMR é \emph{backend-only} e funciona sobre \emph{dynamic imports}, priorizando velocidade de recarga — não há reconciliação de estado no browser como Vite/Webpack fazem.

\subsubsection*{Conceitos-chave}
\begin{itemize}
  \item \textbf{Sem propagação ao browser}: o backend não sincroniza estado de SPA/SSR.
  \item \textbf{Funciona com imports dinâmicos}: controllers, middlewares, listeners já usam \emph{dynamic import} por padrão.
  \item \textbf{Limites (boundaries)}: defina quais arquivos podem sofrer HMR; o restante gera \emph{full reload}.
\end{itemize}

\begin{warningbox}
  Não registre \texttt{config/}, \texttt{start/}, \texttt{.adonisrc.ts} ou \textit{service providers} como \emph{boundaries}. Esses módulos produzem efeitos colaterais e devem disparar \emph{full reload} para manter a aplicação íntegra.
\end{warningbox}

\subsubsection*{Uso}

\begin{enumerate}
  \item Instale o pacote do hook de HMR.
  \item Configure as \textit{boundaries} no \texttt{package.json}.
  \item Rode o servidor com a flag \texttt{--hmr}.
\end{enumerate}

\lstinputlisting[
  language=bash,
  caption={Instalação do HMR hook},
  label={lst:hmr_install}
]{snippets/conceitos-fundamentais/hmr_install.sh}

\lstinputlisting[
  language=json,
  caption={\texttt{package.json}: configuração do \texttt{hotHook} e script \texttt{dev}},
  label={lst:hmr_pkgjson}
]{snippets/conceitos-fundamentais/hmr_package.json}

\lstinputlisting[
  language=bash,
  caption={Rodando o dev server com HMR},
  label={lst:hmr_serve}
]{snippets/conceitos-fundamentais/hmr_serve.sh}

\begin{infobox}
  Em HMR, o AdonisJS constrói uma \emph{árvore de dependências} a partir de \texttt{bin/server.ts}. Somente arquivos importados entram na vigilância. Arquivos não referenciados não disparam recarga.
\end{infobox}

\subsection{Processo de Build com TypeScript}

No desenvolvimento, executamos TS \emph{on-the-fly}; para produção, geramos um \emph{standalone build} JavaScript.

\subsubsection*{Ferramentas}
\begin{itemize}
  \item \textbf{TSC}: type-checking e build de produção.
  \item \textbf{ts-node-maintained}: JIT para executar TS sem compilar (dev).
  \item \textbf{SWC}: acelera o JIT no dev junto ao ts-node.
\end{itemize}

\lstinputlisting[
  language=bash,
  caption={Executando TS sem compilar (server, testes, Ace)},
  label={lst:tsnode_commands}
]{snippets/conceitos-fundamentais/tsnode_commands.sh}

\lstinputlisting[
  language=bash,
  caption={Servidor de desenvolvimento com watcher e integração de assets},
  label={lst:serve_watch}
]{snippets/conceitos-fundamentais/serve_watch.sh}

\lstinputlisting[
  language=bash,
  caption={Build de produção e execução do \texttt{standalone build}},
  label={lst:build_and_run}
]{snippets/conceitos-fundamentais/build_and_run.sh}

\begin{tipbox}
  Em projetos \texttt{"type": "module"}, versões do TypeScript anteriores à 5.7 exigem sufixo \texttt{.js} nos imports mesmo com arquivo \texttt{.ts} no disco. A partir da 5.7, o \texttt{.ts} pode ser aceito via \emph{path rewriting} para caminhos relativos.
\end{tipbox}

\subsection{Scaffolding e Codemods}

\textbf{Scaffolding} gera arquivos a partir de \textit{stubs}. \textbf{Codemods} modificam o código via AST (ts-morph) para registrar providers, middlewares, env, etc.

\subsubsection*{Stubs e Generators}

\lstinputlisting[
  language=TypeScript,
  caption={Ace command mínimo que gera arquivo a partir de stub},
  label={lst:make_using_stub}
]{snippets/conceitos-fundamentais/make_using_stub.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Stub com Tempura/handlebars e \texttt{exports()} definindo destino},
  label={lst:resource_stub}
]{snippets/conceitos-fundamentais/api_resource.stub}

\subsubsection*{Passando argumentos e variáveis}

\lstinputlisting[
  language=TypeScript,
  caption={Ace command aceitando argumento e repassando ao stub},
  label={lst:make_using_stub_args}
]{snippets/conceitos-fundamentais/make_using_stub_args.ts}

\subsubsection*{Codemods comuns}

\lstinputlisting[
  language=TypeScript,
  caption={Registrar middleware (stack do router/named/server)},
  label={lst:codemods_register_mw}
]{snippets/conceitos-fundamentais/register_middleware.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Atualizar \texttt{.adonisrc.ts} (providers, commands, aliases)},
  label={lst:codemods_update_rc}
]{snippets/conceitos-fundamentais/update_rc.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Definir validações de \texttt{Env} e inserir variáveis em \texttt{.env} / \texttt{.env.example}},
  label={lst:codemods_env}
]{snippets/conceitos-fundamentais/env.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Registrar plugin do Japa e políticas do Bouncer},
  label={lst:codemods_japa_policies}
]{snippets/conceitos-fundamentais/japa_policies.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Adicionar plugin do Vite e instalar pacotes},
  label={lst:codemods_vite_install}
]{snippets/conceitos-fundamentais/vite_install.ts}

\begin{warningbox}
  Os codemods assumem convenções padrão de nomes/paths. Alterações drásticas na estrutura podem impedir a aplicação automática das mudanças.
\end{warningbox}

\subsection{Assembler Hooks}

Hooks permitem encaixar lógica em fases do assembler (dev/build/test).

\lstinputlisting[
  language=TypeScript,
  caption={Declarando hooks no \texttt{.adonisrc.ts}},
  label={lst:hooks_rc}
]{snippets/conceitos-fundamentais/hooks_in_adonisrc.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Hook \texttt{onBuildStarting} com lógica customizada},
  label={lst:hook_on_build_starting}
]{snippets/conceitos-fundamentais/on_build_starting.ts}

\begin{infobox}
  Hooks disponíveis: \texttt{onBuildStarting}, \texttt{onBuildCompleted}, \texttt{onDevServerStarted}, \texttt{onSourceFileChanged}.
\end{infobox}

\subsection{Aliases e Tooling Config}

Padronize imports com aliases (ex.: \texttt{\#models/user}) integrando Node ESM e TypeScript.

\lstinputlisting[
  language=json,
  caption={\texttt{package.json}: \texttt{imports} ESM para aliases},
  label={lst:pkg_imports}
]{snippets/conceitos-fundamentais/package_imports.json}

\lstinputlisting[
  language=json,
  caption={\texttt{tsconfig.json}: \texttt{compilerOptions.paths} para o editor/TS},
  label={lst:tsconfig_paths}
]{snippets/conceitos-fundamentais/tsconfig_paths.json}

\lstinputlisting[
  language=TypeScript,
  caption={Uso de alias em código},
  label={lst:alias_usage}
]{snippets/conceitos-fundamentais/alias_usage.ts}

\begin{tipbox}
  Ao usar ESM, garanta \texttt{"type": "module"} no \texttt{package.json}. Se seu editor ainda sugere caminhos relativos, recarregue o TS Server e confirme que o \texttt{tsconfig.json} carregou a base correta.
\end{tipbox}

\chapter{Fundamentos}

\section{Rotas}

As rotas conectam URLs a handlers. No AdonisJS v6, elas moram em start/routes.ts e são definidas com o serviço router.

\begin{infobox}
  Penso nas rotas como uma “interface pública” da aplicação. Uma organização clara (nomes, grupos, prefixos) simplifica navegação, testes e manutenção ao longo do tempo.
\end{infobox}

\subsection{Primeiros exemplos}

\lstinputlisting[
  language=TypeScript,
  caption={Rotas básicas e parâmetro dinâmico},
  label={lst:rotas_basicas}
]{snippets/fundamentos/rotas/start_routes_basic.ts}

O segmento :id captura valores dinâmicos (route params). Você acessa via \texttt{params} no handler.

\begin{tipbox}
  Durante o desenvolvimento, liste as rotas com \texttt{node ace list:routes}. Ajuda muito quando a base cresce.
\end{tipbox}

\lstinputlisting[
  language=bash,
  caption={Listando rotas registradas},
  label={lst:list_routes}
]{snippets/fundamentos/rotas/list_routes.sh}

\subsection{Parâmetros de rota}

\paragraph{Múltiplos parâmetros.} Você pode ter mais de um, cada qual com nome único.

\lstinputlisting[
  language=TypeScript,
  caption={Múltiplos parâmetros na URI},
  label={lst:multi_params}
]{snippets/fundamentos/rotas/route_multiple_params.ts}

\paragraph{Parâmetros opcionais.} Sufixe com \texttt{?}. Sempre coloque opcionais \textit{depois} dos obrigatórios.

\lstinputlisting[
  language=TypeScript,
  caption={Parâmetro opcional},
  label={lst:optional_param}
]{snippets/fundamentos/rotas/route_optional_param.ts}

\paragraph{Wildcard.} Use \texttt{*} no \textit{final} da rota para capturar todos os segmentos remanescentes.

\lstinputlisting[
  language=TypeScript,
  caption={Parâmetro coringa (wildcard)},
  label={lst:wildcard}
]{snippets/fundamentos/rotas/route_wildcard.ts}

\subsection{Matchers (validação e casting de params)}

Por padrão, \texttt{/posts/1} e \texttt{/posts/foo} casam a mesma rota \texttt{/posts/:id}. Use \textit{matchers} para validar (regex) e, se quiser, fazer cast do valor.

\lstinputlisting[
  language=TypeScript,
  caption={Regex + cast para número},
  label={lst:matcher_cast}
]{snippets/fundamentos/rotas/route_matcher_regex_cast.ts}

O roteador oferece \textit{helpers} prontos: \texttt{number()}, \texttt{uuid()}, \texttt{slug()}. Também dá para aplicar globalmente.

\lstinputlisting[
  language=TypeScript,
  caption={Matchers integrados e matcher global},
  label={lst:matchers_inbuilt_global}
]{snippets/fundamentos/rotas/route_matchers_inbuilt_global.ts}

\begin{tipbox}
  Minha prática é impor \texttt{number()} para IDs em \texttt{/resource/:id}. Evita colisões contra endpoints “verbais” (\texttt{/posts/archived}) e melhora a qualidade dos logs.
\end{tipbox}

\subsection{Métodos HTTP e handlers}

Cada método tem seu atalho: \texttt{get}, \texttt{post}, \texttt{put}, \texttt{patch}, \texttt{delete}. Use \texttt{any} com parcimônia (pode mascarar bugs de método).

\lstinputlisting[
  language=TypeScript,
  caption={Rotas por método HTTP},
  label={lst:http_methods}
]{snippets/fundamentos/rotas/http_methods.ts}

Handlers podem ser \textit{inline} (sync/async) ou apontar para controller (criado via IoC automaticamente).

\lstinputlisting[
  language=TypeScript,
  caption={Vinculando rota a um controller},
  label={lst:controller_binding}
]{snippets/fundamentos/rotas/handler_controller_binding.ts}

\subsection{Middleware em rotas}

Aplique com \texttt{.use()}. A ordem importa (grupo antes, rota depois).

\lstinputlisting[
  language=TypeScript,
  caption={Middleware inline em rota},
  label={lst:route_middleware}
]{snippets/fundamentos/rotas/route_middleware_inline.ts}

\subsection{Nomeando rotas e gerando URLs}

Nomeie com \texttt{.as()}; depois gere URLs com o \texttt{router.builder()}.

\lstinputlisting[
  language=TypeScript,
  caption={Nome e URL Builder},
  label={lst:route_name_builder}
]{snippets/fundamentos/rotas/route_named_and_url_builder.ts}

\begin{tipbox}
  Padrão sugerido: \texttt{resource.action} (\texttt{users.index}, \texttt{users.store}). Fica previsível para templates, redirects e testes.
\end{tipbox}

\subsection{Agrupando rotas}

Grupos facilitam aplicar \texttt{prefix}, \texttt{as} e \texttt{use} em lote; também podem ser aninhados.

\lstinputlisting[
  language=TypeScript,
  caption={Grupo com prefixo e nome},
  label={lst:group_prefix_as}
]{snippets/fundamentos/rotas/group_prefix_as.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Grupos aninhados},
  label={lst:nested_groups}
]{snippets/fundamentos/rotas/nested_groups.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Middleware aplicado ao grupo},
  label={lst:group_middleware}
]{snippets/fundamentos/rotas/group_middleware.ts}

\subsection{Rotas por domínio e subdomínios dinâmicos}

Mapeie domínios específicos (útil em multi-tenant ou blog separado) e use segmentos dinâmicos (ex.: \texttt{:tenant}).

\lstinputlisting[
  language=TypeScript,
  caption={Rotas em domínio específico},
  label={lst:domain_routes}
]{snippets/fundamentos/rotas/domain_routes.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Subdomínio dinâmico},
  label={lst:dynamic_subdomain}
]{snippets/fundamentos/rotas/dynamic_subdomain.ts}

\begin{warningbox}
  Em dev, você precisa apontar o host (DNS/hosts/reverso) para que o nome do domínio chegue correto à aplicação; caso contrário, o match do grupo por domínio não dispara.
\end{warningbox}

\subsection{Atalhos \texttt{router.on()} (Edge/Inertia/Redirect)}

Se só deseja renderizar uma view ou redirecionar, \texttt{router.on()} fornece atalhos convenientes.

\lstinputlisting[
  language=TypeScript,
  caption={Render Edge diretamente da rota},
  label={lst:render_edge}
]{snippets/fundamentos/rotas/render_edge.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Render Inertia (se configurado)},
  label={lst:render_inertia}
]{snippets/fundamentos/rotas/render_inertia.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Redirecionamentos com \texttt{on()}},
  label={lst:redirects}
]{snippets/fundamentos/rotas/redirect_examples.ts}

\subsection{Rota atual e ordem de matching}

Acesse metadados da rota atual via \texttt{ctx.route} e confira se a requisição “bate” numa rota com \texttt{request.matchesRoute}.

\lstinputlisting[
  language=TypeScript,
  caption={Rota atual e matchesRoute},
  label={lst:current_route}
]{snippets/fundamentos/rotas/current_request_route.ts}

\begin{warningbox}
  A ordem de registro define o \textit{matching}. Ponha rotas \textbf{mais específicas} acima das genéricas com params.
\end{warningbox}

\lstinputlisting[
  language=TypeScript,
  caption={Específica antes da dinâmica},
  label={lst:ordering}
]{snippets/fundamentos/rotas/ordering_specific_before_dynamic.ts}

\subsection{404 (quando rota não existe)}

Intercepte \texttt{E\_ROUTE\_NOT\_FOUND} no handler global e renderize a página 404.

\lstinputlisting[
  language=TypeScript,
  caption={Tratando 404 no exception handler},
  label={lst:handler_404}
]{snippets/fundamentos/rotas/handler_404_example.ts}

\subsection{URL Builder — extras úteis}

Params posicionais ou por objeto, query string, \texttt{prefixUrl}, \texttt{makeSigned} (com expiração), \texttt{disableRouteLookup} e URLs para domínios específicos.

\lstinputlisting[
  language=TypeScript,
  caption={URL Builder avançado},
  label={lst:url_builder_variants}
]{snippets/fundamentos/rotas/url_builder_variants.ts}

\begin{tipbox}
  Para \textit{signed URLs}, garanta que o \texttt{APP\_KEY} esteja setado adequadamente no ambiente e seja estável entre instâncias. Em produção, adote expiração (\texttt{expiresIn}) por segurança.
\end{tipbox}

\subsection{Estendendo o roteador (macros)}

Quando a equipe precisa de convenções repetíveis (auditoria, tagging, políticas), macros ajudam. Exemplo simples:

\lstinputlisting[
  language=TypeScript,
  caption={Macro no Router com type augmentation},
  label={lst:router_macros}
]{snippets/fundamentos/rotas/router_macros.ts}

\begin{infobox}
  Macros são uma forma elegante de padronizar comportamentos sem “espalhar” código. Úteis em plataformas multi-produto.
\end{infobox}

\section{Controllers}

Controllers organizam os handlers HTTP fora do arquivo de rotas. Em vez de concentrar a lógica em start/routes.ts, movemos o código para classes dentro de app/controllers, deixando as rotas mais legíveis e a aplicação mais modular.

\begin{infobox}
  Controllers não são apenas “pastas diferentes para funções”: eles permitem construir uma camada de orquestração clara, facilitando testes, injeção de dependências e evolução do domínio sem poluir o arquivo de rotas.
\end{infobox}

\subsection{Criando e usando um controller}

Gere um controller pelo Ace:

\lstinputlisting[
  language=bash,
  caption={Gerando um controller},
  label={lst:make_controller}
]{snippets/fundamentos/controllers/make_controller.sh}

Implemente métodos (ex.: \texttt{index}) e retorne dados:

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{UsersController} básico},
  label={lst:users_controller_basic}
]{snippets/fundamentos/controllers/users_controller_basic.ts}

Faça o binding na rota usando import dinâmico (lazy):

\lstinputlisting[
  language=TypeScript,
  caption={Vinculando controller à rota (lazy import)},
  label={lst:routes_bind_users_controller}
]{snippets/fundamentos/controllers/routes_bind_users_controller.ts}

\begin{infobox}
  Ao passar a referência do controller (em vez de instância), o AdonisJS cria um objeto novo a cada requisição e resolve dependências via IoC automaticamente.
\end{infobox}

\begin{tipbox}
  Lazy-loading é importante com HMR e para reduzir o \textit{boot time} conforme o projeto cresce. O plugin ESLint oficial pode sugerir/converter imports padrão para imports dinâmicos.
\end{tipbox}

\subsection{“Magic strings”}

Outra forma de lazy-loading é usar “magic strings”: caminho + método numa única string. Fica visualmente limpo, porém sem \textit{type-safety}.

\lstinputlisting[
  language=TypeScript,
  caption={Magic string na rota},
  label={lst:routes_magic_string}
]{snippets/fundamentos/controllers/routes_magic_string.ts}

\begin{warningbox}
  Se houver typo no caminho, o editor não acusa — o erro aparece só em tempo de execução. Use com critério de equipe.
\end{warningbox}

\subsection{Single-action controllers}

Para ações autoexplicativas, use controllers de ação única com método \texttt{handle()}:

\lstinputlisting[
  language=TypeScript,
  caption={Single-action controller},
  label={lst:single_action_controller}
]{snippets/fundamentos/controllers/register_newsletter_subscription_controller.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Rota apontando para single-action},
  label={lst:routes_bind_single_action}
]{snippets/fundamentos/controllers/routes_bind_single_action.ts}

\subsection{HttpContext no controller}

Métodos de controller recebem \texttt{HttpContext} como primeiro argumento:

\lstinputlisting[
  language=TypeScript,
  caption={Recebendo \texttt{HttpContext} no método},
  label={lst:users_controller_httpcontext}
]{snippets/fundamentos/controllers/users_controller_httpcontext.ts}

\subsection{Dependency Injection (IoC)}

Controllers são instanciados pelo IoC; você pode injetar serviços por construtor:

\lstinputlisting[
  language=TypeScript,
  caption={Serviço simples para \texttt{User}},
  label={lst:services_user_service}
]{snippets/fundamentos/controllers/services_user_service.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Injeção por construtor no controller},
  label={lst:users_controller_di_constructor}
]{snippets/fundamentos/controllers/users_controller_di_constructor.ts}

Ou por método (\textit{method injection}): o \texttt{HttpContext} é sempre o primeiro parâmetro; a injeção vem em seguida.

\lstinputlisting[
  language=TypeScript,
  caption={Injeção por método no controller},
  label={lst:users_controller_di_method}
]{snippets/fundamentos/controllers/users_controller_di_method.ts}

\paragraph{Árvore de dependências.} Qualquer classe injetada pode, por sua vez, receber outras dependências. Você pode, por exemplo, injetar \texttt{HttpContext} no serviço:

\lstinputlisting[
  language=TypeScript,
  caption={Serviço recebendo \texttt{HttpContext} via IoC},
  label={lst:services_user_service_with_ctx}
]{snippets/fundamentos/controllers/services_user_service_with_ctx.ts}

\begin{tipbox}
  Na prática, mantenho controllers “magros”: desestruturam o \texttt{ctx}, delegam validação a Validators e regras de negócio a Services. Isso preserva a clareza e permite testes unitários mais estáveis.
\end{tipbox}

\subsection{Resource-driven controllers (REST)}

Para CRUDs convencionais, gere um controller \textit{resource}:

\lstinputlisting[
  language=bash,
  caption={Scaffold de resource controller},
  label={lst:make_posts_resource}
]{snippets/fundamentos/controllers/make_posts_resource.sh}

O scaffold inclui \texttt{index}, \texttt{create}, \texttt{store}, \texttt{show}, \texttt{edit}, \texttt{update}, \texttt{destroy}:

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{PostsController} (scaffold resumido)},
  label={lst:posts_controller_resource}
]{snippets/fundamentos/controllers/posts_controller_resource.ts}

Registre as rotas com \texttt{router.resource}:

\lstinputlisting[
  language=TypeScript,
  caption={Rotas resource},
  label={lst:routes_resource_posts}
]{snippets/fundamentos/controllers/routes_resource_posts.ts}

\paragraph{Nested e shallow resources.}

\lstinputlisting[
  language=TypeScript,
  caption={Nested resource},
  label={lst:routes_resource_nested}
]{snippets/fundamentos/controllers/routes_resource_nested.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Shallow resource (URLs mais planas)},
  label={lst:routes_shallow_resource}
]{snippets/fundamentos/controllers/routes_shallow_resource.ts}

\paragraph{Nomes e prefixos.}

\lstinputlisting[
  language=TypeScript,
  caption={Nomeação padrão e customizada},
  label={lst:routes_resource_naming}
]{snippets/fundamentos/controllers/routes_resource_naming.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Desligando transformação para \texttt{snake\_case}},
  label={lst:routes_resource_as_transform_off}
]{snippets/fundamentos/controllers/routes_resource_as_transform_off.ts}

\paragraph{API only, only/except.}

\lstinputlisting[
  language=TypeScript,
  caption={API only},
  label={lst:routes_resource_api_only}
]{snippets/fundamentos/controllers/routes_resource_api_only.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Selecionando ações (\texttt{only}/\texttt{except})},
  label={lst:routes_resource_only_except}
]{snippets/fundamentos/controllers/routes_resource_only_except.ts}

\paragraph{Renomeando params.}

\lstinputlisting[
  language=TypeScript,
  caption={Renomeando params em resources},
  label={lst:routes_resource_params}
]{snippets/fundamentos/controllers/routes_resource_params.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Renomeando em nested resources},
  label={lst:routes_resource_nested_params}
]{snippets/fundamentos/controllers/routes_resource_nested_params.ts}

\paragraph{Middleware em resources.}

\lstinputlisting[
  language=TypeScript,
  caption={Aplicando middleware às ações do resource},
  label={lst:routes_resource_middleware}
]{snippets/fundamentos/controllers/routes_resource_middleware.ts}

\begin{warningbox}
  Ao usar \texttt{resource.use('*', ...)} lembre-se: a pilha de middleware será aplicada a todas as ações; combine com \texttt{only/except} quando precisar granularidade.
\end{warningbox}

\section{Request e Response}

Toda requisição HTTP em AdonisJS possui dois protagonistas: \texttt{request} (entrada) e \texttt{response} (saída). Eles vêm do \texttt{HttpContext} e estão disponíveis no handler via desestruturação: \texttt{{ request, response }}.

\begin{infobox}
  Minha regra prática: \textbf{pegar dados no \texttt{request}, validar com Validator (VineJS), delegar a Services e devolver pelo \texttt{response}}. Controllers “magros” reduzem bugs e acoplamento.
\end{infobox}

Request

\subsection{Query string e route params}

\lstinputlisting[
  language=TypeScript,
  caption={Lendo query string (\texttt{request.qs()})},
  label={lst:req_qs}
]{snippets/fundamentos/request_response/request_qs.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Lendo route params (\texttt{request.params()} / \texttt{request.param()})},
  label={lst:req_params}
]{snippets/fundamentos/request_response/request_params.ts}

\subsection{Corpo da requisição}

O body é parseado pelo \textit{body-parser} registrado no \texttt{start/kernel.ts}. Acesse com \texttt{request.body()} ou pegue tudo (body + query) com \texttt{request.all()}.

\lstinputlisting[
  language=TypeScript,
  caption={Body e \texttt{all()}},
  label={lst:req_body_all}
]{snippets/fundamentos/request_response/request_body_all.ts}

\paragraph{Cherry-picking.} Métodos \texttt{only}, \texttt{except} e \texttt{input} servem para selecionar/excluir campos específicos (mesmo se vierem da query).

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{only}, \texttt{except} e \texttt{input}},
  label={lst:req_cherry_picking}
]{snippets/fundamentos/request_response/request_cherry_picking.ts}

\begin{warningbox}
  \textbf{Type-safety}: \texttt{request.body()}, \texttt{all()} e afins não garantem tipos. Para tipagem/parse corretos, valide com VineJS e trabalhe com o resultado validado.
\end{warningbox}

\subsection{URL e método}

\lstinputlisting[
  language=TypeScript,
  caption={URL relativa/absoluta e com query},
  label={lst:req_url}
]{snippets/fundamentos/request_response/request_url.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Método efetivo vs. método original},
  label={lst:req_method}
]{snippets/fundamentos/request_response/request_method.ts}

\subsection{Headers}

\lstinputlisting[
  language=TypeScript,
  caption={Acessando headers},
  label={lst:req_headers}
]{snippets/fundamentos/request_response/request_headers.ts}

\subsection{IP do usuário (proxies) e \texttt{getIp} customizado}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{ip()} e \texttt{ips()}},
  label={lst:req_ip}
]{snippets/fundamentos/request_response/request_ip.ts}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{getIp} customizado no \texttt{config/app.ts}},
  label={lst:req_getip_config}
]{snippets/fundamentos/request_response/config_app_getip.ts}

\begin{tipbox}
  Ajuste \texttt{http.trustProxy} conforme sua infra (Nginx, Caddy, load balancer). Sem isso, o IP pode vir incorreto.
\end{tipbox}

\subsection{Negociação de conteúdo (\texttt{Accept})}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{types()}, \texttt{accepts()} e variações},
  label={lst:req_content_negotiation}
]{snippets/fundamentos/request_response/request_content_negotiation.ts}

\subsection{Request IDs}

\lstinputlisting[
  language=TypeScript,
  caption={Habilitando e usando Request ID},
  label={lst:req_id}
]{snippets/fundamentos/request_response/request_id.ts}

\subsection{Trusted proxies}

\lstinputlisting[
  language=TypeScript,
  caption={Configurações de \texttt{trustProxy}},
  label={lst:req_trust_proxy}
]{snippets/fundamentos/request_response/config_app_trust_proxy.ts}

\subsection{Parser de query string}

\lstinputlisting[
  language=TypeScript,
  caption={Ajustando parser de query string},
  label={lst:req_qs_parser}
]{snippets/fundamentos/request_response/config_app_qs.ts}

\subsection{Method spoofing (HTML forms)}

\lstinputlisting[
  language=TypeScript,
  caption={Habilitando method spoofing},
  label={lst:req_method_spoofing_cfg}
]{snippets/fundamentos/request_response/config_app_method_spoofing.ts}

\lstinputlisting[
  language=html,
  caption={Exemplo de form com \protect\texttt{\_method}},
  label={lst:req_method_spoofing_form}
]{snippets/fundamentos/request_response/form_method_spoofing.html}

\subsection{Estendendo a classe Request}

\lstinputlisting[
  language=TypeScript,
  caption={Macro + augmentation em \texttt{Request}},
  label={lst:req_extend}
]{snippets/fundamentos/request_response/request_extend.ts}

Response

\subsection{Enviando respostas}

Você pode \textit{return} no handler ou usar \texttt{response.send()}. Em \texttt{send()}, o último valor vence.

\lstinputlisting[
  language=TypeScript,
  caption={Retornando valores vs. \texttt{response.send()}},
  label={lst:res_send}
]{snippets/fundamentos/request_response/response_send.ts}

\paragraph{Status e headers.} Prefira \texttt{safeStatus} / \texttt{safeHeader} quando não quer sobrescrever valores já definidos.

\lstinputlisting[
  language=TypeScript,
  caption={Status e headers (seguros e diretos)},
  label={lst:res_status_headers}
]{snippets/fundamentos/request_response/response_status_headers.ts}

\subsection{Streaming e download}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{response.stream()} com tratamento de erro},
  label={lst:res_stream}
]{snippets/fundamentos/request_response/response_stream.ts}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{response.download()} com Etag e callback de erro},
  label={lst:res_download}
]{snippets/fundamentos/request_response/response_download.ts}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{response.attachment()} (forçar salvar)},
  label={lst:res_attachment}
]{snippets/fundamentos/request_response/response_attachment.ts}

\begin{tipbox}
  Para arquivos locais, use \texttt{download()} em vez de \texttt{stream()}: ele já define \texttt{Content-Type} e \texttt{Content-Length}.
\end{tipbox}

\subsection{Redirects (fluente)}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{toPath}, \texttt{toRoute}, \texttt{back}, \texttt{withQs}, \texttt{status}},
  label={lst:res_redirects}
]{snippets/fundamentos/request_response/response_redirects.ts}

\subsection{Abortando requisições}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{response.abort()}},
  label={lst:res_abort}
]{snippets/fundamentos/request_response/response_abort.ts}

\subsection{Hooks pós-resposta e acesso ao \texttt{res} nativo}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{onFinish} e acesso ao objeto \texttt{res}},
  label={lst:res_onfinish_native}
]{snippets/fundamentos/request_response/response_onfinish_native.ts}

\subsection{Serialização e \textit{content-type} automático}

\lstinputlisting[
  language=TypeScript,
  caption={Regras de serialização e inferência de \texttt{content-type}},
  label={lst:res_serialization}
]{snippets/fundamentos/request_response/response_serialization_notes.ts}

\subsection{Estendendo a classe Response}

\lstinputlisting[
  language=TypeScript,
  caption={Macro + augmentation em \texttt{Response}},
  label={lst:res_extend}
]{snippets/fundamentos/request_response/response_extend.ts}

\section{Validations}

A validação de dados em AdonisJS normalmente acontece no controller — o mais cedo possível no ciclo da requisição. Depois de validar, trabalhamos apenas com \textit{payload confiável} para acessar DB, enviar e-mails, enfileirar jobs etc.

\begin{infobox}
  Use validadores pensados por \textbf{ação} (ex.: \texttt{CreatePost}, \texttt{UpdatePost}). Evite “um validador para tudo”: a clareza compensa qualquer duplicação leve de schema.
\end{infobox}

\subsection{Por que VineJS?}

O AdonisJS recomenda o \textbf{VineJS} (rápido, seguro em tempo de execução e com \textit{type-safety} estática). Vem pré-configurado nos kits \texttt{web} e \texttt{api}. Nada impede usar outra lib — basta remover \texttt{@vinejs/vine} —, mas você perderá integrações oficiais (ex.: \texttt{unique}/\texttt{exists} do Lucid).

\lstinputlisting[
  language=bash,
  caption={Instalar e configurar o VineJS},
  label={lst:vine_add}
]{snippets/fundamentos/validations/vine_add.sh}

\subsection{Definindo rotas e controller}

\lstinputlisting[
  language=TypeScript,
  caption={Rotas \texttt{/posts} para \texttt{store} e \texttt{update}},
  label={lst:routes_posts}
]{snippets/fundamentos/validations/routes_posts.ts}

\lstinputlisting[
  language=bash,
  caption={Gerando controller com métodos \texttt{store} e \texttt{update}},
  label={lst:make_controller_post}
]{snippets/fundamentos/validations/make_controller_post.sh}

\lstinputlisting[
  language=TypeScript,
  caption={Scaffold do \texttt{PostsController}},
  label={lst:posts_controller_scaffold}
]{snippets/fundamentos/validations/posts_controller_scaffold.ts}

\subsection{Criando validators}

\lstinputlisting[
  language=bash,
  caption={Gerando arquivo de validators},
  label={lst:make_validator_post}
]{snippets/fundamentos/validations/make_validator_post.sh}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{createPostValidator} e \texttt{updatePostValidator}},
  label={lst:post_validator}
]{snippets/fundamentos/validations/post_validator.ts}

\subsection{Usando validators no controller}

\lstinputlisting[
  language=TypeScript,
  caption={Validando com \texttt{request.validateUsing()} (recomendado)},
  label={lst:posts_controller_with_validateUsing}
]{snippets/fundamentos/validations/posts_controller_with_validateUsing.ts}

\begin{tipbox}
  \textbf{Sem try/catch}: erros de validação viram resposta HTTP automaticamente no \textit{Exception Handler}, respeitando \texttt{Accept} (JSON, JSON:API, HTML com flash, texto).
\end{tipbox}

\subsection{Validando cookies, headers e route params}

\lstinputlisting[
  language=TypeScript,
  caption={Schema que inclui \texttt{cookies}, \texttt{headers} e \texttt{params}},
  label={lst:validator_cookies_headers_params}
]{snippets/fundamentos/validations/validator_cookies_headers_params.ts}

\subsection{Passando metadados para o validator}

Quando a validação depende de informação de runtime (ex.: \texttt{userId} logado), passe \texttt{meta} e tipifique com \texttt{withMetaData}:

\lstinputlisting[
  language=TypeScript,
  caption={Validator com meta tipado e regra \texttt{unique}},
  label={lst:update_user_validator_meta}
]{snippets/fundamentos/validations/update_user_validator_with_meta.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Passando \texttt{meta} pelo \texttt{request.validateUsing()}},
  label={lst:controller_meta_pass}
]{snippets/fundamentos/validations/controller_pass_meta.ts}

\begin{warningbox}
  O \texttt{withMetaData} define \textit{tipos} — o VineJS \textbf{não} valida \texttt{meta} em runtime. Se precisar, valide manualmente no callback de \texttt{withMetaData(...)}.
\end{warningbox}

\subsection{Mensagens e Error Reporter}

\lstinputlisting[
  language=TypeScript,
  caption={Mensagens personalizadas (preload \texttt{start/validator.ts})},
  label={lst:start_validator_messages}
]{snippets/fundamentos/validations/start_validator_messages.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Registrando um \textit{error reporter} customizado},
  label={lst:start_validator_reporter}
]{snippets/fundamentos/validations/start_validator_reporter.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Exemplo mínimo de \textit{JSONAPIErrorReporter}},
  label={lst:jsonapi_reporter}
]{snippets/fundamentos/validations/jsonapi_reporter.ts}

\subsection{Arquivos (rule contribuída pelo AdonisJS)}

O tipo \texttt{vine.file()} é disponibilizado pelo núcleo do AdonisJS. Útil para upload (com tamanho/extensões).

\lstinputlisting[
  language=TypeScript,
  caption={Exemplo de validação de arquivo},
  label={lst:file_validator}
]{snippets/fundamentos/validations/file_validator.ts}

\subsection*{Notas práticas}

\begin{itemize}
  \item Prefira \texttt{request.validateUsing(validator)} ao invés de manipular \texttt{request.all()} manualmente — ele já mescla body, query e files corretamente.
  \item Evite “mega-schemas” dinâmicos; mantenha um por ação. A duplicação mínima favorece leitura e manutenção.
  \item Se a sua equipe usa JSON:API, padronize o \textit{error reporter} pra respostas consistentes.
\end{itemize}

\begin{warningbox}
  Erros comuns: tentar usar APIs antigas (ex.: \texttt{vine.rules}) ou esquecer de exportar o \textit{const} do \texttt{vine.compile(...)}. No VineJS moderno, o fluxo é \texttt{vine.compile(schema)} → \texttt{request.validateUsing(...)}.
\end{warningbox}

\section{Uploads de Arquivos}

O AdonisJS tem suporte nativo a uploads via multipart/form-data. Os arquivos são processados automaticamente pelo BodyParser e gravados no diretório tmp do SO. A partir do controller, você pode acessar, validar e mover para um local persistente (ou para um storage externo).

\begin{infobox}
  Regra de ouro que sigo em apps reais: \textbf{validar cedo, nomear de forma única, limitar extensões/tamanho, e nunca servir caminhos “crus”}. Quando vi isso quebrar, quase sempre era por nome de arquivo previsível ou path traversal.
\end{infobox}

\subsection{Acessando arquivos enviados}

\lstinputlisting[
  language=TypeScript,
  caption={Um único arquivo com \texttt{request.file}},
  label={lst:single_file}
]{snippets/fundamentos/uploads/user_avatars_controller_update.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Vários arquivos com \texttt{request.files}},
  label={lst:multiple_files}
]{snippets/fundamentos/uploads/invoices_controller_update.ts}

\subsection{Validação manual (inline)}

Você pode definir regras no próprio request.file(s) e checar isValid/errors.

\lstinputlisting[
  language=TypeScript,
  caption={Validação inline de avatar},
  label={lst:manual_validate_avatar}
]{snippets/fundamentos/uploads/manual_validate_avatar.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Validação inline de múltiplos documentos},
  label={lst:manual_validate_documents}
]{snippets/fundamentos/uploads/manual_validate_documents.ts}

\begin{tipbox}
  Para respostas de erro consistentes, eu padronizo a estrutura { name, errors } por arquivo. Isso facilita exibir erro “ao lado” do input no frontend.
\end{tipbox}

\subsection{Validando arquivos com VineJS}

Recomendo concentrar a validação no VineJS — o pipeline já converte em resposta HTTP quando falha.

\lstinputlisting[
  language=TypeScript,
  caption={Validator de avatar (\texttt{vine.file}) e uso no controller},
  label={lst:vine_single}
]{snippets/fundamentos/uploads/user_validator_and_controller.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Array de arquivos com \texttt{vine.array(vine.file(...))}},
  label={lst:vine_array}
]{snippets/fundamentos/uploads/create_invoice_validator.ts}

\subsection{Movendo para local persistente}

Após validar, mova o arquivo com file.move(...). Gere nomes únicos com cuid().

\lstinputlisting[
  language=TypeScript,
  caption={Movendo para \texttt{storage/uploads}},
  label={lst:move_basic}
]{snippets/fundamentos/uploads/move_avatar_storage.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Nome único com \texttt{cuid()} + extensão detectada},
  label={lst:move_with_cuid}
]{snippets/fundamentos/uploads/move_avatar_with_cuid.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Salvando o nome do arquivo no banco},
  label={lst:save_filename_db}
]{snippets/fundamentos/uploads/save_avatar_db.ts}

\subsection*{Propriedades úteis (\textit{MultipartFile})}

\texttt{fieldName}, \texttt{clientName}, \texttt{size}, \texttt{extname}, \texttt{type}/\texttt{subtype}, \texttt{tmpPath}, \texttt{fileName}/\texttt{filePath} (após \texttt{move}), \texttt{errors}, \texttt{validated}, \texttt{isValid}, \texttt{hasErrors}, \texttt{meta}.

\subsection{Servindo arquivos com segurança}

\lstinputlisting[
  language=TypeScript,
  caption={Servindo uploads com proteção a path traversal},
  label={lst:serve_download}
]{snippets/fundamentos/uploads/routes_serve_uploads.ts}

\begin{warningbox}
  Nunca aceite caminhos vindos do usuário sem normalizar e checar \textbf{path traversal}. Evite concatenar strings de caminho — centralize tudo em um diretório “raiz”.
\end{warningbox}

\subsection*{Drive (recomendado)}

O Drive oferece uma abstração segura para local/S3/GCS com API unificada e proteções (inclui checagens de path). Para produção, prefira Drive ao “fazer na mão”. (Você configura o provider e usa operações de put/get/exists, etc.)

\subsection{Avançado: processando o stream manualmente}

Se quiser processar o multipart por conta própria, desative o auto-processamento no BodyParser e use request.multipart.

\lstinputlisting[
  language=TypeScript,
  caption={Desligando auto-processamento e processando stream},
  label={lst:stream_manual}
]{snippets/fundamentos/uploads/assets_controller_stream.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Validando partes do stream (tamanho/extensões)},
  label={lst:stream_validation}
]{snippets/fundamentos/uploads/assets_controller_stream_validate.ts}

\begin{tipbox}
  No modo manual, chame \texttt{part.pause()} e \texttt{part.on('data', reporter)} — sem isso, a validação \textit{não} acontece. Trate \texttt{error} no stream.
\end{tipbox}

\subsection{BodyParser: configuração essencial}

Você pode ajustar métodos permitidos, limites, \textit{encodings}, conversão de strings vazias para \texttt{null}, e o parser multipart.

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{config/bodyparser.ts} com opções principais},
  label={lst:bodyparser_config}
]{snippets/fundamentos/uploads/config_bodyparser.ts}

\begin{infobox}
  Em formulários HTML, habilite \texttt{convertEmptyStringsToNull} para não gravar strings vazias no DB quando o campo deveria ser \texttt{NULL}.
\end{infobox}

\section{Middleware}

\subsection{Visão geral}

Middleware são funções encadeadas que rodam antes do handler de rota. Cada uma pode: (a) abortar a requisição lançando exceção, (b) encerrar a resposta, ou (c) chamar next() para seguir o pipeline. No AdonisJS, usamos middleware para: BodyParser, sessões, autenticação, assets estáticos, etc. Você também cria os seus, como “GeoIP do usuário”, “Tenant header”, “Rate limiting”, e por aí vai.

\begin{tipbox}
  Padrão que sigo: \textbf{tudo que cruza várias rotas} (ex.: auditoria, correlação, tenant) entra como middleware; regras de negócio ficam fora.
\end{tipbox}

\subsection{Stacks de middleware}

O AdonisJS separa a execução em três frentes: server, router (globais) e nomeados.

\subsection{Server middleware stack}

Roda em \textbf{todas} as requisições, mesmo sem rota correspondente. Útil p/ estáticos, observabilidade, hardening.

\lstinputlisting[
  language=TypeScript,
  caption={Registrando server middleware em \texttt{start/kernel.ts}},
  label={lst:start_kernel_server}
]{snippets/fundamentos/middleware/start_kernel_server.ts}

\subsection{Router (globais) middleware stack}

Roda em toda requisição que \textbf{bate em uma rota}. Ex.: BodyParser, session, auth global.

\lstinputlisting[
  language=TypeScript,
  caption={Registrando router middleware global em \texttt{start/kernel.ts}},
  label={lst:start_kernel_router}
]{snippets/fundamentos/middleware/start_kernel_router.ts}

\subsection{Coleção de middleware nomeados}

São middleware que só executam quando atribuídos à rota/grupo. Exporte a coleção para usar em start/routes.ts.

\lstinputlisting[
  language=TypeScript,
  caption={Coleção nomeada e exportada em \texttt{start/kernel.ts}},
  label={lst:start_kernel_named}
]{snippets/fundamentos/middleware/start_kernel_named.ts}

\subsection{Criando middleware}

Geramos com Ace; a classe implementa handle(ctx, next).

\lstinputlisting[
  language=bash,
  caption={Criando um middleware},
  label={lst:make_middleware}
]{snippets/fundamentos/middleware/make_middleware.sh}

\lstinputlisting[
  language=TypeScript,
  caption={Esqueleto de \protect\texttt{app/middleware/user\_location\_middleware.ts}},
  label={lst:user_location_base}
]{snippets/fundamentos/middleware/user_location_middleware.ts}

\subsection{Abortar, continuar ou encerrar sem \texttt{next()}}

\lstinputlisting[
  language=TypeScript,
  caption={Abortando a requisição com exceção},
  label={lst:user_location_abort}
]{snippets/fundamentos/middleware/user_location_abort.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Continuando o pipeline com \texttt{await next()}},
  label={lst:user_location_continue}
]{snippets/fundamentos/middleware/user_location_continue.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Encerrando a resposta sem chamar \texttt{next()}},
  label={lst:user_location_end}
]{snippets/fundamentos/middleware/user_location_end.ts}

\subsection{Atribuindo a rotas e grupos}

\lstinputlisting[
  language=TypeScript,
  caption={Aplicando middleware em rota e múltiplos middleware},
  label={lst:routes_apply_mw}
]{snippets/fundamentos/middleware/routes_apply_middleware.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Aplicando middleware a um grupo de rotas},
  label={lst:routes_group_mw}
]{snippets/fundamentos/middleware/routes_group_middleware.ts}

\subsection{Parâmetros em middleware}

Middleware nomeados podem receber opções (ex.: \texttt{auth} com guard).

\lstinputlisting[
  language=TypeScript,
  caption={Middleware com parâmetro (guard)},
  label={lst:auth_mw_param}
]{snippets/fundamentos/middleware/auth_middleware_param.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Usando o guard na rota},
  label={lst:routes_auth_guard}
]{snippets/fundamentos/middleware/routes_auth_guard.ts}

\subsection{Dependency Injection}

Middleware são instanciados via IoC — você pode injetar serviços.

\lstinputlisting[
  language=TypeScript,
  caption={Serviço \texttt{GeoIpService}},
  label={lst:geoip_service}
]{snippets/fundamentos/middleware/geoip_service.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Injetando serviço no middleware com \texttt{@inject()}},
  label={lst:user_location_injected}
]{snippets/fundamentos/middleware/user_location_injected.ts}

\subsection{Fluxo de execução (downstream/upstream)}

Código antes do next() trata a \textit{request} (downstream). Depois do next(), você pode inspecionar/mutar a \textit{response} (upstream).

\subsection{Exceções e upstream garantido}

Exceções viram respostas HTTP pelo Exception Handler global. Não precisa try/catch para garantir upstream — o framework garante a execução após next().

\subsection{Mutando a \textit{response}: standard/stream/download}

\lstinputlisting[
  language=TypeScript,
  caption={Lendo/mutando \textit{standard response}},
  label={lst:mutate_standard}
]{snippets/fundamentos/middleware/mutate_standard_response.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Inspecionando \textit{stream} de resposta},
  label={lst:inspect_stream}
]{snippets/fundamentos/middleware/inspect_stream.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Inspecionando \textit{file download}},
  label={lst:inspect_download}
]{snippets/fundamentos/middleware/inspect_file_download.ts}

\subsection{Testando middleware (unit e pipeline)}

\lstinputlisting[
  language=TypeScript,
  caption={Teste unitário com \texttt{testUtils.createHttpContext()}},
  label={lst:test_unit}
]{snippets/fundamentos/middleware/test_user_location_unit.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Compondo pipeline de middleware com \texttt{server.pipeline()}},
  label={lst:test_pipeline}
]{snippets/fundamentos/middleware/test_server_pipeline.ts}

\section{Erros e Depuração}

Depurar bem encurta ciclos de feedback e evita “console.log sprawl”. No AdonisJS, costumo combinar três camadas: (1) debugger do VSCode para parar o fluxo e inspecionar variáveis, (2) Dump and Die (dd) para visualização rica e imediata, e (3) logs e exception handler bem configurados para entender o que acontece em produção.

\begin{tipbox}
  Se o breakpoint não “para”: verifique se o VSCode está usando a configuração certa, se o projeto está rodando com \texttt{ace.js} e se o TypeScript está gerando \textit{source maps}. Em projetos grandes, \textit{lazy imports} em controllers ajudam a reduzir o tempo de boot e a manter o \textit{attach} responsivo.
\end{tipbox}

\subsection{Depurando com o VSCode}

Crie o arquivo .vscode/launch.json e rode o servidor com o debugger.

\lstinputlisting[
  language=json,
  caption={VSCode: iniciar servidor em modo debug},
  label={lst:vscode_launch_dev}
]{snippets/fundamentos/erros-depuracao/vscode_launch_dev.json}

\textbf{Como usar}: abra a \textit{Command Palette}
→
→ \textit{Debug: Select and Start Debugging}
→
→ escolha “Dev server”.

\subsection{Depurando testes}

Adicione outra configuração para rodar testes no modo debug (útil para travar em asserts).

\lstinputlisting[
  language=json,
  caption={VSCode: rodar testes com debug},
  label={lst:vscode_launch_tests}
]{snippets/fundamentos/erros-depuracao/vscode_launch_tests.json}

\subsection{Depurando outros comandos Ace (Attach)}

Para qualquer comando Ace, use o modo \textit{attach} e inicie o processo com --inspect.

\lstinputlisting[
  language=json,
  caption={VSCode: attach em processo Node com \texttt{--inspect}},
  label={lst:vscode_launch_attach}
]{snippets/fundamentos/erros-depuracao/vscode_launch_attach.json}

\lstinputlisting[
  language=bash,
  caption={Anexando o debugger a um comando Ace},
  label={lst:node_inspect_ace}
]{snippets/fundamentos/erros-depuracao/node_inspect_ace.sh}

\begin{warningbox}
  Sempre rode o processo alvo pelo \textbf{terminal integrado} do VSCode — assim o attach encontra a porta 9229 automaticamente.
\end{warningbox}

\subsection{Depurando templates Edge}

Não há breakpoints do VSCode dentro do Edge. Use o \verb|@debugger| como \textit{breakpoint} em template.

\lstinputlisting[
  language=html,
  caption={\texttt{@debugger}, \texttt{@dd} e \texttt{@dump} em Edge},
  label={lst:edge_debug_dump}
]{snippets/fundamentos/erros-depuracao/edge_debug_dump.edge}

\subsection{Dump and Die (\texttt{dd})}

dd() imprime com contexto (fonte, profundidade, estáticos/protótipos) e interrompe o fluxo — perfeito para “fotografar” o estado durante uma requisição.

\lstinputlisting[
  language=TypeScript,
  caption={Usando \texttt{dd} em rota para inspecionar dados},
  label={lst:dd_in_route}
]{snippets/fundamentos/erros-depuracao/dd_in_route.ts}

\textbf{Temas HTML}: \texttt{nightOwl}, \texttt{catppuccin}, \texttt{minLight}.

\subsection{Configurando o Dumper}

Ajuste profundidade, colapso de tipos, inspeção de estáticos/protótipos.

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{config/app.ts}: configuração do Dumper},
  label={lst:dumper_config}
]{snippets/fundamentos/erros-depuracao/dumper_config.ts}

\subsection{Logs de debug do framework}

Use NODE\_DEBUG para ver logs internos do AdonisJS (e até módulos nativos do Node).

\lstinputlisting[
  language=bash,
  caption={Ativando logs de debug do AdonisJS e módulos do Node},
  label={lst:node_debug_env}
]{snippets/fundamentos/erros-depuracao/node_debug_env.sh}

\begin{tipbox}
  Combine com um \texttt{logger} estruturado e \texttt{requestId} habilitado para correlacionar eventos de uma mesma requisição.
\end{tipbox}

\subsection{Tratamento de exceções (HttpExceptionHandler)}

O \textbf{ExceptionHandler} centraliza \textit{rendering} e \textit{reporting}, com \textit{content negotiation} e \textit{debug mode} (Youch) em dev.

\lstinputlisting[
  language=TypeScript,
  caption={Handler base com \textit{debug mode} e \textit{status pages} em produção},
  label={lst:http_exception_handler_base}
]{snippets/fundamentos/erros-depuracao/http_exception_handler_base.ts}

\subsection{Registrando o handler no servidor}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{start/kernel.ts}: registrando o error handler},
  label={lst:server_error_handler_register}
]{snippets/fundamentos/erros-depuracao/server_error_handler_register.ts}

\subsection{Customizando \textit{handle}}

Exemplo tratando \texttt{E\_VALIDATION\_ERROR} com 422.

\lstinputlisting[
  language=TypeScript,
  caption={Tratando validação como 422},
  label={lst:validation_422}
]{snippets/fundamentos/erros-depuracao/validation_422.ts}

\subsection{Status pages}

Páginas para \texttt{404} e \texttt{500..599}.

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{statusPages} por faixa de status},
  label={lst:status_pages}
]{snippets/fundamentos/erros-depuracao/status_pages.ts}

\subsection{Reporting, logging e filtros}

Ignorando \textit{status} ou \textit{codes} específicos; adicionando contexto aos logs.

\lstinputlisting[
  language=TypeScript,
  caption={Ignorando status/códigos e enriquecendo logs},
  label={lst:report_filters}
]{snippets/fundamentos/erros-depuracao/report_filters.ts}

\subsection{Exceções personalizadas}

Crie classes de exceção, defina \texttt{status}/\texttt{code}, implemente \texttt{handle}/\texttt{report}.

\lstinputlisting[
  language=bash,
  caption={Gerando exceção via Ace},
  label={lst:make_exception}
]{snippets/fundamentos/erros-depuracao/make_exception.sh}

\lstinputlisting[
  language=TypeScript,
  caption={Exceção personalizada com \texttt{status} e \texttt{code} estáticos},
  label={lst:unauthorized_exception}
]{snippets/fundamentos/erros-depuracao/unauthorized_exception.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Lançando exceção com payload customizado},
  label={lst:throw_unauthorized}
]{snippets/fundamentos/erros-depuracao/throw_unauthorized.ts}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{handle} e \texttt{report} na própria exceção},
  label={lst:exception_handle_report}
]{snippets/fundamentos/erros-depuracao/exception_handle_report.ts}

\subsection{Narrowing de tipos de erro}

Exemplo com erro exportado pelo core.

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{instanceof} para tratar erro específico},
  label={lst:instanceof_core_error}
]{snippets/fundamentos/erros-depuracao/instanceof_core_error.ts}

\begin{examplebox}
  Regra prática que adoto: \textbf{erro esperado} (ex.: rota inexistente, validação)
  →
  → trate e logue em \texttt{warn/info}. \textbf{erro inesperado} (ex.: crash de dependência, I/O)
  →
  → \texttt{error} + correlação por \texttt{requestId} + alerta no observability.
\end{examplebox}

\section{Estado de sessão e cookies}

Sessão guarda estado entre requisições (ex.: usuário logado, preferências), enquanto cookies são pequenos valores enviados pelo navegador em cada requisição. No AdonisJS, a sessão vem do pacote @adonisjs/session (com várias “stores”), e cookies são lidos pelo request e escritos pelo response.

\begin{tipbox}
  Para apps escaláveis, prefira \textbf{Redis} ou \textbf{DynamoDB} como store de sessão. Em projetos pequenos ou sem servidor compartilhado, \textbf{cookie} ou \textbf{file} podem bastar.
\end{tipbox}

\subsection{Instalação}

Instale e configure a sessão:

\lstinputlisting[
  language=bash,
  caption={Instalação do pacote de sessão},
  label={lst:add-session}
]{snippets/fundamentos/sessao-cookies/add_session.sh}

\subsection{Configuração da Sessão}

O arquivo config/session.ts centraliza idade, cookie e qual store usar. Abaixo um exemplo com \textit{cookie}, \textit{file}, \textit{redis} e \textit{dynamodb} já prontos.

\lstinputlisting[
  language=TypeScript,
  caption={Configuração de sessão (múltiplas stores disponíveis)},
  label={lst:session-config}
]{snippets/fundamentos/sessao-cookies/config_session.ts}

E não esqueça de validar o SESSION\_DRIVER em start/env.ts:

\lstinputlisting[
  language=TypeScript,
  caption={Validação do \protect\texttt{SESSION\_DRIVER} nas variáveis de ambiente},
  label={lst:env-validate-session}
]{snippets/fundamentos/sessao-cookies/start_env.ts}

\begin{warningbox}
  Para usar \textbf{Redis}, configure antes \texttt{@adonisjs/redis}. Para \textbf{DynamoDB}, passe \textit{clientConfig} ou uma instância do \texttt{DynamoDBClient}.
\end{warningbox}

\subsection{Lojas (stores)}

O AdonisJS traz stores: \texttt{cookie}, \texttt{file}, \texttt{redis}, \texttt{dynamodb} e \texttt{memory} (testes). Você pode habilitar várias e alternar por ambiente.

\lstinputlisting[
  language=TypeScript,
  caption={Exemplo completo de stores configuradas},
  label={lst:stores}
]{snippets/fundamentos/sessao-cookies/stores.ts}

\subsection{Exemplo básico de uso}

Gravando preferência de tema em sessão e lendo depois:

\lstinputlisting[
  language=TypeScript,
  caption={Rotas usando \texttt{session.put} e \texttt{session.get}},
  label={lst:session-basic-example}
]{snippets/fundamentos/sessao-cookies/session_basic_example.ts}

\subsection{Tipos e API da Sessão}

A sessão serializa valores com \texttt{JSON.stringify}. Você pode usar \texttt{string}, \texttt{number}, \texttt{bigInt}, \texttt{boolean}, \texttt{null}, \texttt{object}, \texttt{array} e \texttt{Date} (vira ISO).

\lstinputlisting[
  language=TypeScript,
  caption={Operações comuns de sessão: get/put/has/forget/pull/inc/dec/clear},
  label={lst:session-api}
]{snippets/fundamentos/sessao-cookies/session_api.ts}

\subsection{Ciclo de vida e regeneração}

O ID é único e persiste até expirar. Regenerar o ID evita \textit{session fixation} (o pacote \texttt{@adonisjs/auth} já faz isso após login).

\lstinputlisting[
  language=TypeScript,
  caption={Regenerando o ID de sessão},
  label={lst:session-regenerate}
]{snippets/fundamentos/sessao-cookies/session_regenerate.ts}

\subsection{Flash messages}

Dados de uma requisição para a seguinte (padrão em \textit{POST/Redirect/GET}). Útil para feedback e erros de validação.

\lstinputlisting[
  language=TypeScript,
  caption={Gravando \textit{flash} e redirecionando},
  label={lst:flash-basic}
]{snippets/fundamentos/sessao-cookies/flash_basic.ts}

\lstinputlisting[
  language=html,
  caption={Lendo \textit{flash} no Edge: \texttt{@flashMessage} e \texttt{@inputError}},
  label={lst:flash-edge}
]{snippets/fundamentos/sessao-cookies/flash_edge.edge}

\lstinputlisting[
  language=TypeScript,
  caption={Atalhos para \textit{flash} de dados de formulários},
  label={lst:flash-shortcuts}
]{snippets/fundamentos/sessao-cookies/flash_shortcuts.ts}

\begin{tipbox}
  \texttt{request.validateUsing} integra com sessão: erros e valores anteriores são \textit{flashados} automaticamente quando há \textit{session middleware}.
\end{tipbox}

\subsection{Eventos da Sessão}

O pacote despacha eventos (leitura, escrita, destruição). Use-os para instrumentação/observabilidade. (Consulte a referência de eventos do pacote.)

\subsection{Store customizada}

Implemente \texttt{SessionStoreContract} com \texttt{read}, \texttt{write}, \texttt{destroy}, \texttt{touch} e exponha uma \textit{factory} para usar no \texttt{config}.

\lstinputlisting[
  language=TypeScript,
  caption={Exemplo de Store custom (MongoDB) com factory},
  label={lst:custom-store}
]{snippets/fundamentos/sessao-cookies/custom_store_mongodb.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Ligando a store custom no \texttt{config/session.ts}},
  label={lst:custom-store-config}
]{snippets/fundamentos/sessao-cookies/custom_store_config.ts}

\begin{warningbox}
  Ao persistir, serialize o objeto; ao ler, desserialize. \texttt{MessageBuilder} do AdonisJS pode ajudar a padronizar.
\end{warningbox}

\subsection{Cookies}

Cookies são lidos do \texttt{request} e escritos pelo \texttt{response}. O AdonisJS oferece cookies \textbf{assinados} (padrão), \textbf{criptografados} e \textbf{plain} (para acesso via \texttt{document.cookie} quando necessário).

\subsection{Ler, escrever e apagar}

\lstinputlisting[
  language=TypeScript,
  caption={Leitura, escrita e remoção de cookies},
  label={lst:cookies-basic}
]{snippets/fundamentos/sessao-cookies/cookies_basic.ts}

\subsection{Configuração padrão}

Opções globais ficam em \texttt{config/app.ts} (seção \texttt{http.cookie}).

\lstinputlisting[
  language=TypeScript,
  caption={Opções globais de cookies (\texttt{config/app.ts})},
  label={lst:cookies-config}
]{snippets/fundamentos/sessao-cookies/config_app_cookie.ts}

\begin{tipbox}
  Em produção, mantenha \texttt{secure: true} e \texttt{sameSite: 'lax'} (ou \texttt{'strict'}). Se o front estiver em domínio diferente, revise \texttt{domain} e \texttt{sameSite}.
\end{tipbox}

\subsection{Tipos de cookies}
Assinados (padrão)

Impedem adulteração (assinatura inválida faz o cookie ser ignorado).

\lstinputlisting[
  language=TypeScript,
  caption={Cookie assinado: set e get},
  label={lst:cookies-signed}
]{snippets/fundamentos/sessao-cookies/cookies_signed.ts}

Criptografados

Além de assinados, têm conteúdo ilegível (use para dados sensíveis).

\lstinputlisting[
  language=TypeScript,
  caption={Cookie criptografado: set e get},
  label={lst:cookies-encrypted}
]{snippets/fundamentos/sessao-cookies/cookies_encrypted.ts}

Plain

Para leitura no cliente via \texttt{document.cookie}. Pode desligar a codificação quando precisar enviar um token já codificado.

\lstinputlisting[
  language=TypeScript,
  caption={Cookie \textit{plain} (com e sem codificação)},
  label={lst:cookies-plain}
]{snippets/fundamentos/sessao-cookies/cookies_plain.ts}

\begin{warningbox}
  Se o front precisa ler cookie no \texttt{browser}, \texttt{httpOnly} deve ser \texttt{false} para \textit{plain}. Para autenticação baseada em cookie, combine com \texttt{SameSite} e \texttt{CSRF} corretamente.
\end{warningbox}

\section{Logger}

O AdonisJS fornece um logger embutido (baseado em Pino) com suporte a stdout, arquivos e serviços externos. O Pino emite logs em NDJSON (um JSON por linha), focando em alto desempenho.

\begin{tipbox}
  Durante requisições HTTP, prefira \texttt{ctx.logger} — ele injeta o \textit{request id} automaticamente (quando habilitado), facilitando o \textit{tracing}.
\end{tipbox}

\subsection{Uso básico}

\lstinputlisting[
  language=TypeScript,
  caption={Uso do logger global e no contexto HTTP},
  label={lst:logger-uso}
]{snippets/fundamentos/logger/logger_uso.ts}

\subsection{Configuração base}

A configuração fica em \texttt{config/logger.ts}. Você pode ter múltiplos loggers e escolher um como \textit{default}.

\lstinputlisting[
  language=TypeScript,
  caption={Configuração base do logger},
  label={lst:logger-config}
]{snippets/fundamentos/logger/config_logger.ts}

\begin{tipbox}
  Para incluir o \textit{request id} automaticamente nos logs HTTP, ative em \texttt{config/app.ts}:
\end{tipbox}

\lstinputlisting[
  language=TypeScript,
  caption={Habilitando \texttt{generateRequestId}},
  label={lst:logger-request-id}
]{snippets/fundamentos/logger/config_app_request_id.ts}

\subsection{Transports e \textit{targets}}

Os \textit{targets} definem onde e como os logs são escritos (ex.: \texttt{pino/file}, \texttt{pino-pretty}). Você pode condicionar por ambiente usando o helper \texttt{targets()}.

\lstinputlisting[
  language=TypeScript,
  caption={Targets condicionais com \texttt{targets.pushIf()}},
  label={lst:logger-targets}
]{snippets/fundamentos/logger/config_logger_targets.ts}

\begin{infobox}
  \textbf{File target} (\texttt{pino/file}) escreve em \textit{file descriptor} (1 = stdout).
  \textbf{Pretty target} (\texttt{pino-pretty}) formata a saída para leitura humana.
\end{infobox}

\subsection{Múltiplos loggers}

Defina vários loggers por nome e selecione em tempo de execução.

\lstinputlisting[
  language=TypeScript,
  caption={Múltiplos loggers e seleção em runtime},
  label={lst:logger-multi}
]{snippets/fundamentos/logger/logger_multiplos.ts}

\subsection{Injeção de dependências}

Você pode injetar o \texttt{Logger} em serviços/controladores. Em requisições, a instância é \textit{request-aware}.

\lstinputlisting[
  language=TypeScript,
  caption={Injeção de \texttt{Logger} em serviço},
  label={lst:logger-di}
]{snippets/fundamentos/logger/logger_di.ts}

\subsection{Níveis e métodos}

Métodos compatíveis com Pino: \texttt{trace}, \texttt{debug}, \texttt{info}, \texttt{warn}, \texttt{error}, \texttt{fatal}. Você pode enviar um objeto extra para \textit{bindings} e usar \texttt{err} para imprimir erros.

\lstinputlisting[
  language=TypeScript,
  caption={Exemplos de chamadas de log por nível},
  label={lst:logger-metodos}
]{snippets/fundamentos/logger/logger_metodos.ts}

\subsection{Log condicional}

Evite computações caras quando o nível não está ativo.

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{isLevelEnabled} e \texttt{ifLevelEnabled}},
  label={lst:logger-condicional}
]{snippets/fundamentos/logger/logger_condicional.ts}

\subsection{\textit{Child logger}}

Crie \textit{children} com \textit{bindings} fixos (ex.: \texttt{requestId}) ou nível diferente.

\lstinputlisting[
  language=TypeScript,
  caption={Criando e usando \textit{child logger}},
  label={lst:logger-child}
]{snippets/fundamentos/logger/logger_child.ts}

\subsection{Escrevendo em arquivo e rotação}

Para arquivo, use \texttt{pino/file}. Para rotação, utilize \texttt{logrotate} (sistema) ou um pacote como \texttt{pino-roll}.

\lstinputlisting[
  language=TypeScript,
  caption={Escrevendo em arquivo com \texttt{pino/file}},
  label={lst:logger-file}
]{snippets/fundamentos/logger/config_logger_file.ts}

\lstinputlisting[
  language=bash,
  caption={Instalando \texttt{pino-roll} para rotação},
  label={lst:logger-roll-install}
]{snippets/fundamentos/logger/install_pino_roll.sh}

\lstinputlisting[
  language=TypeScript,
  caption={Rotação diária com \texttt{pino-roll}},
  label={lst:logger-roll}
]{snippets/fundamentos/logger/config_logger_roll.ts}

\subsection{Protegendo dados sensíveis}

Use \texttt{redact} para mascarar chaves (via \texttt{fast-redact}) ou envolva valores com \texttt{Secret}.

\lstinputlisting[
  language=TypeScript,
  caption={Redação de campos sensíveis no \texttt{config/logger.ts}},
  label={lst:logger-redact-config}
]{snippets/fundamentos/logger/config_logger_redact.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Redação em runtime e uso de \texttt{Secret}},
  label={lst:logger-redact-uso}
]{snippets/fundamentos/logger/logger_redact_secret.ts}








\section{Environment Variables}

Variáveis de ambiente mantêm segredos (chaves, senhas) e configuram o app por ambiente (dev, test, prod) sem acoplar valores no código-fonte. Em AdonisJS, além do process.env, usamos o módulo \texttt{env} para \textbf{validar}, \textbf{tipar} e \textbf{carregar} múltiplos arquivos \texttt{.env}.

\begin{tipbox}
  Prefira \texttt{env.get()} ao \texttt{process.env}: você ganha validação na inicialização, tipagem estática e suporte a múltiplos \texttt{.env}.
\end{tipbox}

\subsection{Lendo variáveis}

\lstinputlisting[
  language=TypeScript,
  caption={Comparando \texttt{process.env} com o módulo \texttt{env}},
  label={lst:env-uso}
]{snippets/fundamentos/env/env_uso.ts}

\subsection{Compartilhando com Edge (SSR)}

Para usar \texttt{env} nas views (somente server-side), crie um preload \texttt{start/view.ts} e exponha \texttt{env} como global do Edge.

\lstinputlisting[
  language=TypeScript,
  caption={Preload para compartilhar \texttt{env} com o Edge (SSR)},
  label={lst:env-edge}
]{snippets/fundamentos/env/start_view.ts}

\begin{warningbox}
  Isso \textbf{não} expõe \texttt{env} ao navegador — apenas durante a renderização no servidor.
\end{warningbox}

\subsection{Validando variáveis em \texttt{start/env.ts}}

Defina o schema com \texttt{Env.create}. A validação ocorre quando o arquivo é importado (normalmente via arquivos de \texttt{config/}).

\lstinputlisting[
  language=TypeScript,
  caption={Schema e carregamento de \texttt{.env} com validação},
  label={lst:env-schema}
]{snippets/fundamentos/env/start_env.ts}

\begin{infobox}
  O schema também \textbf{informa tipos estáticos}: \texttt{env.get('PORT')} infere \texttt{number} se \texttt{PORT} for \texttt{Env.schema.number()}.
\end{infobox}

\subsection{API do schema (exemplos)}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{string} (opcionalidade e formatos: host, url, email)},
  label={lst:env-schema-string}
]{snippets/fundamentos/env/schema_string_examples.ts}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{boolean} (casts e opcionalidade)},
  label={lst:env-schema-boolean}
]{snippets/fundamentos/env/schema_boolean.ts}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{number} (casts e opcionalidade)},
  label={lst:env-schema-number}
]{snippets/fundamentos/env/schema_number.ts}

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{enum} (array de literais e TS enum)},
  label={lst:env-schema-enum}
]{snippets/fundamentos/env/schema_enum.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Função custom para validar e transformar (ex.: \texttt{PORT})},
  label={lst:env-schema-custom}
]{snippets/fundamentos/env/schema_custom.ts}

\subsection{Arquivos \texttt{.env} por ambiente}
Desenvolvimento

\lstinputlisting[
  language=bash,
  caption={\texttt{.env} (desenvolvimento)},
  label={lst:env-dev}
]{snippets/fundamentos/env/env_development.env}

Produção

\lstinputlisting[
  language=bash,
  caption={Lendo \protect\texttt{.env} do root ou \protect\texttt{ENV\_PATH}},
  label={lst:env-prod}
]{snippets/fundamentos/env/scripts_env_path.sh}

Testes

\lstinputlisting[
  language=bash,
  caption={\texttt{.env.test} sobrescreve valores de \texttt{.env}},
  label={lst:env-test}
]{snippets/fundamentos/env/env_test.env}

\begin{infobox}
  Ordem de carregamento (maior prioridade em cima):

  \texttt{.env.{NODE\_ENV}.local} \quad

  \texttt{.env.local} (exceto test) \quad

  \texttt{.env.{NODE\_ENV}} \quad

  \texttt{.env}
\end{infobox}

\subsection{Identificadores e interpolação}

Você pode registrar \textit{identifiers} (prefixos) para decodificar valores no parse.

\lstinputlisting[
  language=TypeScript,
  caption={Registrando identificador \texttt{base64:} em \texttt{start/env.ts}},
  label={lst:env-identifier}
]{snippets/fundamentos/env/start_env_identifier.ts}

\lstinputlisting[
  language=TypeScript,
  caption={Usando \texttt{EnvParser} inline (exemplo didático)},
  label={lst:env-parser-inline}
]{snippets/fundamentos/env/env_parser_inline.ts}

\subsection{Substituição de variáveis e escaping}

\lstinputlisting[
  language=bash,
  caption={Substituição entre variáveis no \texttt{.env}},
  label={lst:env-substitution}
]{snippets/fundamentos/env/env_substitution.env}

\lstinputlisting[
  language=bash,
  caption={Escapando \protect\texttt{\$} quando for valor literal},
  label={lst:env-escape}
]{snippets/fundamentos/env/env_escape.env}

\chapter{Banco de Dados com Lucid}

Este capítulo introduz o uso de bancos SQL no AdonisJS, com foco no \textit{Lucid ORM}. A proposta aqui é dar a visão geral e o “primeiro contato”: por que usar um ORM, quando usar o Lucid, como instalar, criar o primeiro modelo, rodar migrations, fazer CRUD básico, como integrar \emph{outros} ORMs quando necessário e um panorama de testes e Redis como suporte à camada de dados. Os detalhes avançados (relacionamentos, hooks, transações, serialização, consultas complexas) ficam para as próximas seções do livro.

\section{Panorama: SQL e ORMs no AdonisJS}

\subsection{SQL e por que um ORM}
Bancos relacionais continuam sendo a base de muitos sistemas. Em AdonisJS você pode usar o que preferir: drivers SQL puros, query builders ou ORMs. Um ORM simplifica o \textit{boilerplate}, dá tipagem e ergonomia ao escrever consultas, e integra com outras partes do framework (ex.: Auth e validação).

\subsection{Opções populares (resumo introdutório)}
\begin{itemize}
  \item \textbf{Lucid} — Query builder + Active Record sobre Knex, mantido pela equipe do AdonisJS. Integrações prontas (Auth, validação), migrations, factories, seeders.
  \item \textbf{Prisma} — ORM popular com modelos declarativos, migrações, tipagem forte e DX refinada.
  \item \textbf{Kysely} — Query builder \emph{end-to-end} tipado. Leve e direto, sem modelos.
  \item \textbf{Drizzle ORM} — Minimalista, muito usado na comunidade.
  \item \textbf{MikroORM} — ORM baseado em Knex, verboso porém maduro.
  \item \textbf{TypeORM} — Amplo no ecossistema TypeScript.
\end{itemize}

\begin{tipbox}
  AdonisJS \textbf{não obriga} o uso do Lucid. Se sua equipe já domina Prisma, Kysely ou outro, é viável integrá-los — só fique atento às integrações (ex.: Auth) que o Lucid oferece de fábrica.
\end{tipbox}

\section{Por que Lucid (quando e por quê)}

\subsection{Pontos fortes do Lucid}
\begin{itemize}
  \item Query builder fluente (Knex) + recursos SQL avançados (CTEs, \textit{window}, JSON, locks).
  \item Modelos \textit{class-based} (Active Record): relações, hooks, serialização.
  \item Migrations incrementais; factories e seeders.
  \item Integrações prontas com Auth e validação (regras \texttt{unique}/\texttt{exists}).
  \item Projeto maduro, de longa data com Knex.
\end{itemize}

\subsection{Quando considerar outro ORM}
Se você precisa de um fluxo declarativo com \emph{schema} central (Prisma), ou de um query builder minimalista (Kysely/Drizzle), pode optar por eles. Só lembre: você fará algumas pontes manuais (ex.: provedor de usuário no Auth).

\section{Começando com o Lucid}

\subsection{Instalação}
\lstinputlisting[
  language=bash,
  caption={Adicionar Lucid ao projeto},
  label={lst:lucid-install}
]{snippets/lucid/introducao/install_lucid.sh}

\subsection{Seu primeiro modelo}
\lstinputlisting[
  language=bash,
  caption={Gerando o modelo \texttt{User}},
  label={lst:lucid-make-model-user}
]{snippets/lucid/introducao/make_model_user.sh}

\lstinputlisting[
  language=TypeScript,
  caption={Modelo inicial \texttt{User}},
  label={lst:lucid-user-model}
]{snippets/lucid/introducao/user_model.ts}

\subsection{Migrations em 60 segundos}
\lstinputlisting[
  language=bash,
  caption={Criando e executando migration \texttt{users}},
  label={lst:lucid-migrations-commands}
]{snippets/lucid/introducao/migration_commands.sh}

\lstinputlisting[
  language=TypeScript,
  caption={Migration \texttt{users} (esqueleto)},
  label={lst:lucid-migration-users}
]{snippets/lucid/introducao/migration_users.ts}

\subsection{Query Builder e Model}
Use o serviço \texttt{db} para consultas diretas:
\lstinputlisting[
  language=TypeScript,
  caption={Consulta direta com \texttt{db.from('users')}},
  label={lst:lucid-db-query}
]{snippets/lucid/introducao/query_builder_db.ts}

Ou use o modelo para consultas tipadas:
\lstinputlisting[
  language=TypeScript,
  caption={Consulta com \texttt{User.query()}},
  label={lst:lucid-model-query}
]{snippets/lucid/introducao/user_query_example.ts}

\subsection{CRUD básico}
\lstinputlisting[
  language=TypeScript,
  caption={Exemplos de CRUD básico com \texttt{User}},
  label={lst:lucid-crud-basico}
]{snippets/lucid/introducao/crud_basico.ts}

\section{Usando \emph{outro} ORM no AdonisJS (noções)}

\subsection{Auth sem Lucid: provedor de usuário}
Se você trocar o Lucid por outro ORM/biblioteca, precisará implementar um \textit{User Provider} para o Auth (por exemplo, \texttt{SessionUserProviderContract}). Exemplo conceitual com Kysely (ponte mínima entre o guard e seu usuário):

\lstinputlisting[
  language=TypeScript,
  caption={\texttt{SessionKyselyUserProvider}: ponte mínima para o guard de sessão},
  label={lst:auth-session-kysely-provider}
]{snippets/lucid/introducao/session_kysely_user_provider.ts}

\begin{warningbox}
  Ao não usar Lucid, regras como \texttt{unique}/\texttt{exists} (integração com o validador) não estarão prontas: você precisará prover alternativas.
\end{warningbox}

\section{Redis como apoio à camada de dados (visão geral)}

\subsection{Para que usar}
Redis é útil como \textit{cache}, \textit{rate limiting}, filas simples e \textit{pub/sub}. No AdonisJS, use \texttt{@adonisjs/redis} (\emph{wrapper} sobre ioredis) para conexões nomeadas, clusters e assinatura de canais.

\subsection{Instalação e configuração básica}
\lstinputlisting[
  language=bash,
  caption={Instalação do pacote Redis para AdonisJS},
  label={lst:redis-install}
]{snippets/lucid/introducao/install_redis.sh}

\lstinputlisting[
  language=TypeScript,
  caption={Config Redis (resumo)},
  label={lst:redis-config}
]{snippets/lucid/introducao//redis_config.ts}

\subsection{Uso rápido e Pub/Sub}
\lstinputlisting[
  language=TypeScript,
  caption={SET/GET e assinatura de canal com Redis},
  label={lst:redis-quick-pubsub}
]{snippets/lucid/introducao//redis_quick_pubsub.ts}

\begin{infobox}
  Erros de conexão são registrados e há estratégia de \textit{retry} por padrão. Em produção, monitore eventos e configure \textit{retry/backoff} adequados.
\end{infobox}

\section{Testes com banco de dados (primeiros passos)}

\subsection{Reset por migration x truncamento}
Você pode \textbf{migrar e desfazer} ao fim do ciclo de testes, garantindo DB limpo sempre:
\lstinputlisting[
  language=TypeScript,
  caption={tests bootstrap — migrar e limpar},
  label={lst:tests-migrate-clean}
]{snippets/lucid/introducao/tests_bootstrap_migrate.ts}

Para grandes \emph{schemas}, prefira \textbf{truncar tabelas} (mantém o schema, limpa dados entre execuções):
\lstinputlisting[
  language=TypeScript,
  caption={tests bootstrap — truncar tabelas},
  label={lst:tests-truncate}
]{snippets/lucid/introducao/tests_bootstrap_truncate.ts}

\subsection{Transação global (quando não usar)}
Transação por teste facilita limpeza, mas \textbf{não} funciona se seu código testado já usa transações aninhadas:
\lstinputlisting[
  language=TypeScript,
  caption={Transação global por teste (use com cautela)},
  label={lst:tests-global-tx}
]{snippets/lucid/introducao/tests_global_tx.ts}

\subsection{Seeds em testes}
\lstinputlisting[
  language=TypeScript,
  caption={Seeds no bootstrap de testes},
  label={lst:tests-seed}
]{snippets/lucid/introducao/tests_bootstrap_seed.ts}

\section{Próximos passos (o que virá depois)}
\begin{itemize}
  \item Modelos em profundidade: colunas, \textit{serialization}, \textit{computed}, \textit{scopes}.
  \item Relacionamentos: \texttt{hasOne}, \texttt{hasMany}, \texttt{belongsTo}, \texttt{manyToMany}, \textit{eager loading} e \textit{pivot}.
  \item Hooks de modelo e eventos.
  \item Consultas avançadas (CTEs, \textit{window functions}, JSON), \textit{soft delete}, paginação.
  \item Transações e bloqueios de linha; padrões de repositório/serviço.
  \item Factories e seeders em cenários reais.
\end{itemize}

\begin{tipbox}
  Se você já usa outro ORM (Prisma, Kysely, Drizzle), mantenha este capítulo como referência para integrações do ecossistema AdonisJS (Auth, validação, testes, Redis e convenções).
\end{tipbox}

\chapter{Autenticação e Autorização}
\section{Autenticação com Tokens}
\section{Session Auth}
\section{Middleware de Autenticação}
\section{RBAC - Roles e Permissões}

\chapter{Segurança}
\section{Proteção CSRF}
\section{Validação de Dados}
\section{Protegendo Rotas}
\section{CORS e Headers}
\section{Env Security}

\chapter{Views e Templates com EdgeJS}
\section{Introdução ao Edge}
\section{Sintaxe e Templates}
\section{Interpolação}
\section{Condicionais e Loops}
\section{Partials e Layouts}
\section{Slots, Props e Injeção}
\section{Debugging no Edge}
\section{Criando Custom Tags}

\chapter{Testes com Japa}
\section{Introdução ao Japa}
\section{Instalação e Configuração}
\section{Testando Código Assíncrono}
\section{Agrupando Testes}
\section{Hooks de Ciclo de Vida}
\section{Datasets}
\section{Macros de Teste}
\section{Test Suites e Exceptions}
\section{Coverage e Test Reporters}

\chapter{Aprofundando no AdonisJS}
\section{Ace Commands}
\section{Criando Comandos Customizados}
\section{Digging Deeper: Internals}
\section{Boas Práticas}
\section{Debugging e Performance}
\section{Deploy e Produção}

\chapter{Referências}
\section{Documentação Oficial}
\section{Comunidade e Recursos}
\section{Repositórios e Links Úteis}

% ======================
% Lucid ORM
\part{Lucid ORM}

\chapter{Introdução ao Lucid}
\section{Instalação e Uso}
\section{Debugging e Troubleshooting}
\section{Transações e Paginação}
\section{Database Seeders}
\section{Validation Rules}

\chapter{Query Builders}
\section{Select Query Builder}
\section{Insert Query Builder}
\section{Raw Queries}

\chapter{Migrations}
\section{Introdução}
\section{Schema Builder}
\section{Table Builder}

\chapter{Models}
\section{CRUD Operations}
\section{Hooks}
\section{Query Builder em Models}
\section{Naming Strategy}
\section{Query Scopes}
\section{Serialização de Models}
\section{Relacionamentos}
\section{Model Factories}

% ======================
% VineJS - Validação
\part{VineJS - Validações Poderosas}

\chapter{Guia de Uso do VineJS}
\section{Introdução}
\section{Getting Started}
\section{Schema 101}
\section{HTML Forms e Surpresas}
\section{Validações Condicionais}
\section{Field Context}
\section{Mensagens Customizadas}
\section{Error Reporter}
\section{Helpers}

\chapter{Tipos de Schema}
\section{String}
\section{Boolean}
\section{Number}
\section{Date}
\section{Accepted}
\section{Enum}
\section{Literal}
\section{Object}
\section{Record}
\section{Array}
\section{Tuple}
\section{Union}
\section{Any}

\chapter{Extendendo VineJS}
\section{Criando Custom Rules}
\section{Criando Custom Schema Types}

% ======================
% Japa - Test Runner
\part{Japa - Framework de Testes}

\chapter{Guia de Testes com Japa}
\section{Introdução}
\section{Instalação e Uso}
\section{Testando Código Assíncrono}
\section{Grouping Tests}
\section{Lifecycle Hooks}
\section{Datasets}
\section{Test Macros}
\section{Exceptions e Test Suites}
\section{Filtering Tests e Skipping Tests}
\section{Bail Mode}
\section{Test Reporters}
\section{Coverage}

\chapter{Plugins}
\section{Assert}
\section{OpenAPI Assertions}
\section{Expect}
\section{API Client}
\section{Browser Client}
\section{File System}
\section{Expect Types}
\section{Snapshot}

% =======================
% Glossário
% =======================
\chapter*{Glossário}
\addcontentsline{toc}{chapter}{Glossário}
\begin{description}
  \item[API] Interface de Programação de Aplicações.
  \item[Framework] Estrutura que fornece suporte para desenvolvimento.
  \item[Compilador] Programa que traduz código para linguagem de máquina.
\end{description}

% =======================
% Índice de Termos
% =======================
\printindex

\end{document}
